#ifndef VEXCL_SYMBOLIC_HPP
#define VEXCL_SYMBOLIC_HPP

/*
The MIT License

Copyright (c) 2012 Denis Demidov <ddemidov@ksu.ru>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

/**
 * \file   generator.hpp
 * \author Denis Demidov <ddemidov@ksu.ru>
 * \brief  OpenCL kernel generator.
 */

#ifdef WIN32
#  pragma warning(push)
#  pragma warning(disable : 4267 4290)
#  define NOMINMAX
#endif

#ifndef _MSC_VER
#  define VEXCL_VARIADIC_TEMPLATES
#endif

#ifndef __CL_ENABLE_EXCEPTIONS
#  define __CL_ENABLE_EXCEPTIONS
#endif

#include <iostream>
#include <string>
#include <sstream>
#include <map>
#include <exception>
#include <stdexcept>
#include <type_traits>
#include <vexcl/util.hpp>

/// Vector expression template library for OpenCL.
namespace vex {

/// Kernel generation interface.
namespace generator {

/// \cond INTERNAL
template <bool dummy = true>
class recorder {
    public:
	static void set(std::ostream &s) {
	    os = &s;
	}

	static std::ostream& get() {
	    return os ? *os : std::cout;
	}

    private:
	static std::ostream *os;
};

template <bool dummy>
std::ostream* recorder<dummy>::os = 0;

inline std::ostream& get_recorder() {
    return recorder<>::get();
}

/// \endcond

/// Set output stream for kernel recorder.
inline void set_recorder(std::ostream &os) {
    recorder<>::set(os);
}

/// \cond INTERNAL
template <class T, class Enable = void>
struct terminal {
    static std::string get(const T &v) {
	std::ostringstream s;
	s << std::scientific << std::setprecision(18) << v;
	return s.str();
    }
};

template <class T>
struct terminal< T, typename std::enable_if<T::is_symbolic>::type > {
    static std::string get(const T &v) {
	return v.get_string();
    }
};
/// \endcond

/// Symbolic value.
/**
 * This class is used for recording of expression sequence which would later
 * become single autogenerated kernel. See examples/symbolic.cpp for the usage
 * example.
 */
template <typename T>
class symbolic {
    public:
	static const bool is_symbolic = true;

	/// Scope/Type of the symbolic variable.
	enum scope_type {
	    LocalVar        = 0, ///< Local variable.
	    VectorParameter = 1, ///< Vector kernel parameter.
	    ScalarParameter = 2, ///< Scalar kernel parameter.
	};

	/// Constness of vector parameter.
	enum constness_type {
	    NonConst = 0,   ///< Parameter should be written back at kernel exit.
	    Const = 1	    ///< Parameter is readonly.
	};

	/// Default constructor. Results in local kernel variable.
	symbolic(scope_type scope = LocalVar, constness_type constness = NonConst)
	    : num(index++), scope(scope), constness(constness)
	{
	    if (scope == LocalVar) {
		get_recorder()
		    << type_name<T>() << " " << get_string() << ";\n";
	    }
	}

	/// Copy constructor. Results in local variable initialized by give value.
	symbolic(const symbolic &s)
	    : num(index++), scope(LocalVar), constness(NonConst)
	{
	    get_recorder()
		<< type_name<T>() << " " << get_string() << " = "
		<< s.get_string() << ";\n";
	}

	/// Expression constructor. Results in local variable initialized by expression.
	template <class Expr>
	explicit symbolic(const Expr &expr)
	    : num(index++),
	      scope(LocalVar), constness(NonConst)
	{
	    get_recorder()
		<< type_name<T>() << " " << get_string() << " = "
		<< terminal<Expr>::get(expr) << ";\n";
	}

	/// Returns variable name.
	std::string get_string() const {
	    std::ostringstream s;
	    s << "var" << num;
	    return s.str();
	}

	/// Assignment operator. Results in assignment written to recorder.
	const symbolic& operator=(const symbolic &s) {
	    get_recorder()
		<< get_string() << " = " << s.get_string() << ";\n";
	    return *this;
	}

	/// Assignment operator. Results in assignment written to recorder.
	template <class Expr>
	const symbolic& operator=(const Expr &expr) const {
	    get_recorder()
		<< get_string() << " = " << terminal<Expr>::get(expr) << ";\n";
	    return *this;
	}

#define COMPOUND_ASSIGNMENT(cop, op) \
	template <class Expr> \
	const symbolic& operator cop(const Expr &expr) { \
	    return *this = *this op expr; \
	}

	COMPOUND_ASSIGNMENT(+=, +);
	COMPOUND_ASSIGNMENT(-=, -);
	COMPOUND_ASSIGNMENT(*=, *);
	COMPOUND_ASSIGNMENT(/=, /);
	COMPOUND_ASSIGNMENT(%=, %);
	COMPOUND_ASSIGNMENT(&=, &);
	COMPOUND_ASSIGNMENT(|=, |);
	COMPOUND_ASSIGNMENT(^=, ^);
	COMPOUND_ASSIGNMENT(<<=, <<);
	COMPOUND_ASSIGNMENT(>>=, >>);

#undef COMPOUND_ASSIGNMENT

	/// Read parameter value to local variable at kernel enter.
	std::string read() const {
	    std::ostringstream s;
	    s << type_name<T>() << " " << get_string() << " = p_" << get_string();

	    switch (scope) {
		case VectorParameter:
		    s << "[idx];\n";
		    break;
		case ScalarParameter:
		    s << ";\n";
		    break;
		case LocalVar:
		    break;
	    }

	    return s.str();
	}

	/// Write local variable to parameter at kernel exit.
	std::string write() const {
	    std::ostringstream s;

	    if (scope == VectorParameter && constness == NonConst)
		s << "p_" << get_string() << "[idx] = " << get_string() << ";\n";

	    return s.str();
	}

	/// Returns string for parameter declaration.
	std::string prmdecl() const {
	    std::ostringstream s;

	    if (scope == VectorParameter)
		s << "global ";

	    if (constness == Const)
		s << "const ";

	    s << type_name<T>();

	    if (scope == VectorParameter)
		s << "*";

	    s << " p_" << get_string();

	    return s.str();
	}
    private:
	static size_t index;
	size_t num;

	scope_type     scope;
	constness_type constness;
};

template <typename T>
size_t symbolic<T>::index = 0;

/// Symbolic expression template.
template <class LHS, binop::kind OP, class RHS>
struct symbolic_expression {
    static const bool is_symbolic = true;

    symbolic_expression(const LHS &lhs, const RHS &rhs) : lhs(lhs), rhs(rhs) {}

    const LHS &lhs;
    const RHS &rhs;

    std::string get_string() const {
	std::ostringstream s;
	s << "(" << terminal<LHS>::get(lhs) << " " << binop::traits<OP>::oper()
	  << " " << terminal<RHS>::get(rhs) << ")";
	return s.str();
    }
};

/// \cond INTERNAL
template <class T, class Enable = void>
struct valid_symb
    : public std::false_type {};

template <class T>
struct valid_symb<T, typename std::enable_if<std::is_arithmetic<T>::value>::type>
    : std::true_type {};

template <class T>
struct valid_symb<T, typename std::enable_if<T::is_symbolic>::type>
    : std::true_type {};
/// \endcond

#define DEFINE_BINARY_OP(kind, oper) \
template <class LHS, class RHS> \
typename std::enable_if<valid_symb<LHS>::value && valid_symb<RHS>::value, \
symbolic_expression<LHS, kind, RHS> \
>::type \
operator oper(const LHS &lhs, const RHS &rhs) { \
    return symbolic_expression<LHS, kind, RHS>(lhs, rhs); \
}

DEFINE_BINARY_OP(binop::Add,          + )
DEFINE_BINARY_OP(binop::Subtract,     - )
DEFINE_BINARY_OP(binop::Multiply,     * )
DEFINE_BINARY_OP(binop::Divide,       / )
DEFINE_BINARY_OP(binop::Remainder,    % )
DEFINE_BINARY_OP(binop::Greater,      > )
DEFINE_BINARY_OP(binop::Less,         < )
DEFINE_BINARY_OP(binop::GreaterEqual, >=)
DEFINE_BINARY_OP(binop::LessEqual,    <=)
DEFINE_BINARY_OP(binop::Equal,        ==)
DEFINE_BINARY_OP(binop::NotEqual,     !=)
DEFINE_BINARY_OP(binop::BitwiseAnd,   & )
DEFINE_BINARY_OP(binop::BitwiseOr,    | )
DEFINE_BINARY_OP(binop::BitwiseXor,   ^ )
DEFINE_BINARY_OP(binop::LogicalAnd,   &&)
DEFINE_BINARY_OP(binop::LogicalOr,    ||)
DEFINE_BINARY_OP(binop::RightShift,   >>)
DEFINE_BINARY_OP(binop::LeftShift,    <<)

#undef DEFINE_BINARY_OP

/// Autogenerated kernel.
template <class... Args>
class Kernel {
    public:
	/// Launches kernel with provided parameters.
	template <class... Param>
	void operator()(const Param&... param) {
	    static_assert(
		    sizeof...(Param) == sizeof...(Args),
		    "Wrong number of kernel parameters"
		    );

	    for(uint d = 0; d < queue.size(); d++) {
		if (size_t psize = prm_size(d, param...)) {
		    cl::Context context = queue[d].getInfo<CL_QUEUE_CONTEXT>();

		    uint pos = 0;
		    krn[context()].setArg(pos++, psize);

		    set_params(krn[context()], d, pos, param...);

		    queue[d].enqueueNDRangeKernel(
			    krn[context()],
			    cl::NullRange,
			    alignup(psize, wgs[context()]),
			    wgs[context()]
			    );
		}
	    }
	}

    private:
	    template <class... SymPrm> friend
	    Kernel<SymPrm...> build_kernel(
		    const std::vector<cl::CommandQueue> &queue,
		    const std::string &name, const std::string& body, const SymPrm&... args
		    );

	Kernel(
		const std::vector<cl::CommandQueue> &queue,
		const std::string &name, const std::string &body,
		const Args&... args
	      ) : queue(queue)
	{
	    std::ostringstream source;

	    source
		<< standard_kernel_header
		<< "kernel void " << name << "(\n"
		<< "\t" << type_name<size_t>() << " n";

	    declare_params(source, args...);

	    source
		<< "\n\t)\n{\n"
		<< "size_t idx = get_global_id(0);\n"
		<< "if (idx < n) {\n";

	    read_params(source, args...);

	    source << body;
	    
	    write_params(source, args...);

	    source << "}\n}\n";

#ifdef VEXCL_SHOW_KERNELS
	    std::cout << source.str() << std::endl;
#endif

	    for(auto q = queue.begin(); q != queue.end(); q++) {
		cl::Context context = q->getInfo<CL_QUEUE_CONTEXT>();
		cl::Device  device  = q->getInfo<CL_QUEUE_DEVICE>();

		auto program = build_sources(context, source.str());

		krn[context()] = cl::Kernel(program, name.c_str());
		wgs[context()] = kernel_workgroup_size(krn[context()], device);
	    }
	}

	std::vector<cl::CommandQueue> queue;

	std::map<cl_context, cl::Kernel> krn;
	std::map<cl_context, uint> wgs;

	void declare_params(std::ostream &os) const {}

	template <class Head, class... Tail>
	void declare_params(std::ostream &os, const Head &head, const Tail&... tail) {
	    os << ",\n\t" << head.prmdecl();
	    declare_params(os, tail...);
	}

	void read_params(std::ostream &os) const {}

	template <class Head, class... Tail>
	void read_params(std::ostream &os, const Head &head, const Tail&... tail) {
	    os << head.read();
	    read_params(os, tail...);
	}

	void write_params(std::ostream &os) const {}

	template <class Head, class... Tail>
	void write_params(std::ostream &os, const Head &head, const Tail&... tail) {
	    os << head.write();
	    write_params(os, tail...);
	}

	size_t prm_size(uint d) const {
	    throw std::logic_error(
		    "Kernel has to have at least one vector parameter"
		    );
	}

	template <class Head, class... Tail>
	size_t prm_size(uint d, const Head &head, const Tail&... tail) const {
	    if (std::is_arithmetic<Head>::value)
		return prm_size(d, tail...);
	    else 
		return KernelGenerator<Head>(head).part_size(d);
	}

	void set_params(cl::Kernel &k, uint d, uint &p) const {}

	template <class Head, class... Tail>
	void set_params(cl::Kernel &k, uint d, uint &p, const Head &head,
		const Tail&... tail) const
	{
	    KernelGenerator<Head>(head).kernel_args(k, d, p);
	    set_params(k, d, p, tail...);
	}
};

/// Builds kernel from recorded expression sequence and symbolic parameter list.
template <class... Args>
Kernel<Args...> build_kernel(
	const std::vector<cl::CommandQueue> &queue,
	const std::string &name, const std::string& body, const Args&... args
	)
{
    return Kernel<Args...>(queue, name, body, args...);
}

/// \cond INTERNAL
template <class func_name, class... Expr>
class symbolic_builtin {
    public:
	static const bool is_symbolic = true;

	symbolic_builtin(const Expr&... expr) : expr(std::ref(expr)...) {}

	std::string get_string() const {
	    std::ostringstream s;
	    s << func_name::value() << "(";
	    output_names out(s);
	    for_each(out);
	    s << ")";
	    return s.str();
	}
    private:
	const std::tuple<std::reference_wrapper<const Expr>...> expr;

	template <uint pos = 0, class Function>
	typename std::enable_if<(pos == sizeof...(Expr)), void>::type
	for_each(Function &f) const
	{ }

	template <uint pos = 0, class Function>
	typename std::enable_if<(pos < sizeof...(Expr)), void>::type
	for_each(Function &f) const
	{
	    f( std::get<pos>(expr).get() );
	    for_each<pos+1, Function>(f);
	}

	struct output_names {
	    std::ostringstream &s;
	    output_names(std::ostringstream &s) : s(s) {}

	    template <class E>
	    void operator()(const E &e) const {
		s << terminal<E>::get(e);
	    }

	};
};
/// \endcond

#define DEFINE_BUILTIN_FUNCTION(name) \
template <class Expr> \
typename std::enable_if<valid_symb<Expr>::value, \
	 symbolic_builtin<name##_name, Expr> \
	 >::type \
name(const Expr &expr) { \
    return symbolic_builtin<name##_name, Expr>(expr); \
}

DEFINE_BUILTIN_FUNCTION(acos)
DEFINE_BUILTIN_FUNCTION(acosh)
DEFINE_BUILTIN_FUNCTION(acospi)
DEFINE_BUILTIN_FUNCTION(asin)
DEFINE_BUILTIN_FUNCTION(asinh)
DEFINE_BUILTIN_FUNCTION(asinpi)
DEFINE_BUILTIN_FUNCTION(atan)
DEFINE_BUILTIN_FUNCTION(atan2)
DEFINE_BUILTIN_FUNCTION(atanh)
DEFINE_BUILTIN_FUNCTION(atanpi)
DEFINE_BUILTIN_FUNCTION(atan2pi)
DEFINE_BUILTIN_FUNCTION(cbrt)
DEFINE_BUILTIN_FUNCTION(ceil)
DEFINE_BUILTIN_FUNCTION(copysign)
DEFINE_BUILTIN_FUNCTION(cos)
DEFINE_BUILTIN_FUNCTION(cosh)
DEFINE_BUILTIN_FUNCTION(cospi)
DEFINE_BUILTIN_FUNCTION(erfc)
DEFINE_BUILTIN_FUNCTION(erf)
DEFINE_BUILTIN_FUNCTION(exp)
DEFINE_BUILTIN_FUNCTION(exp2)
DEFINE_BUILTIN_FUNCTION(exp10)
DEFINE_BUILTIN_FUNCTION(expm1)
DEFINE_BUILTIN_FUNCTION(fabs)
DEFINE_BUILTIN_FUNCTION(fdim)
DEFINE_BUILTIN_FUNCTION(floor)
DEFINE_BUILTIN_FUNCTION(fma)
DEFINE_BUILTIN_FUNCTION(fmax)
DEFINE_BUILTIN_FUNCTION(fmin)
DEFINE_BUILTIN_FUNCTION(fmod)
DEFINE_BUILTIN_FUNCTION(fract)
DEFINE_BUILTIN_FUNCTION(frexp)
DEFINE_BUILTIN_FUNCTION(hypot)
DEFINE_BUILTIN_FUNCTION(ilogb)
DEFINE_BUILTIN_FUNCTION(ldexp)
DEFINE_BUILTIN_FUNCTION(lgamma)
DEFINE_BUILTIN_FUNCTION(lgamma_r)
DEFINE_BUILTIN_FUNCTION(log)
DEFINE_BUILTIN_FUNCTION(log2)
DEFINE_BUILTIN_FUNCTION(log10)
DEFINE_BUILTIN_FUNCTION(log1p)
DEFINE_BUILTIN_FUNCTION(logb)
DEFINE_BUILTIN_FUNCTION(mad)
DEFINE_BUILTIN_FUNCTION(maxmag)
DEFINE_BUILTIN_FUNCTION(minmag)
DEFINE_BUILTIN_FUNCTION(modf)
DEFINE_BUILTIN_FUNCTION(nan)
DEFINE_BUILTIN_FUNCTION(nextafter)
DEFINE_BUILTIN_FUNCTION(pow)
DEFINE_BUILTIN_FUNCTION(pown)
DEFINE_BUILTIN_FUNCTION(powr)
DEFINE_BUILTIN_FUNCTION(remainder)
DEFINE_BUILTIN_FUNCTION(remquo)
DEFINE_BUILTIN_FUNCTION(rint)
DEFINE_BUILTIN_FUNCTION(rootn)
DEFINE_BUILTIN_FUNCTION(round)
DEFINE_BUILTIN_FUNCTION(rsqrt)
DEFINE_BUILTIN_FUNCTION(sin)
DEFINE_BUILTIN_FUNCTION(sincos)
DEFINE_BUILTIN_FUNCTION(sinh)
DEFINE_BUILTIN_FUNCTION(sinpi)
DEFINE_BUILTIN_FUNCTION(sqrt)
DEFINE_BUILTIN_FUNCTION(tan)
DEFINE_BUILTIN_FUNCTION(tanh)
DEFINE_BUILTIN_FUNCTION(tanpi)
DEFINE_BUILTIN_FUNCTION(tgamma)
DEFINE_BUILTIN_FUNCTION(trunc)

#undef DEFINE_BUILTIN_FUNCTION

} // namespace generator;

} // namespace vex;

#endif
