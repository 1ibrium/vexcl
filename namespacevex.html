<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>VexCL: vex Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VexCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vex Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Vector expression template library for OpenCL.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevex_1_1backend"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1backend.html">backend</a></td></tr>
<tr class="memdesc:namespacevex_1_1backend"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend-specific functionality. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1constants"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1constants.html">constants</a></td></tr>
<tr class="memdesc:namespacevex_1_1constants"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mathematical constants. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1fft"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1fft.html">fft</a></td></tr>
<tr class="memdesc:namespacevex_1_1fft"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier Transform. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1Filter"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1Filter.html">Filter</a></td></tr>
<tr class="memdesc:namespacevex_1_1Filter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device filters. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1generator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1generator.html">generator</a></td></tr>
<tr class="memdesc:namespacevex_1_1generator"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvex_1_1generator_1_1Kernel.html" title="Autogenerated kernel. ">Kernel</a> generation interface. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1random"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1random.html">random</a></td></tr>
<tr class="memdesc:namespacevex_1_1random"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvex_1_1Random.html" title="A random generator. ">Random</a> generators. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random generator.  <a href="structvex_1_1Random.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1RandomNormal.html">RandomNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns normal distributed random numbers.  <a href="structvex_1_1RandomNormal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1FFT.html">FFT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier Transform.  <a href="structvex_1_1FFT.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1Context.html">Context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">VexCL context holder.  <a href="classvex_1_1Context.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1mba.html">mba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scattered data interpolation with multilevel B-Splines.  <a href="classvex_1_1mba.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html">multivector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for several vex::vectors.  <a href="classvex_1_1multivector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1is__vector__expression.html">is_vector_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-filter for VexCL vector expressions.  <a href="structvex_1_1is__vector__expression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1is__multivector__expression.html">is_multivector_expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta-filter for VexCL multivector expressions.  <a href="structvex_1_1is__multivector__expression.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1stopwatch.html">stopwatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stopwatch that computes the median and mean of individual timings.  <a href="classvex_1_1stopwatch.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1profiler.html">profiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for gathering and printing OpenCL and Host profiling info.  <a href="classvex_1_1profiler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1SUM.html">SUM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summation. Should be used as a template parameter for <a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression. ">Reductor</a> class.  <a href="structvex_1_1SUM.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1MAX.html">MAX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element. Should be used as a template parameter for <a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression. ">Reductor</a> class.  <a href="structvex_1_1MAX.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1MIN.html">MIN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element. Should be used as a template parameter for <a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression. ">Reductor</a> class.  <a href="structvex_1_1MIN.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1Reductor.html">Reductor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel reduction of arbitrary expression.  <a href="classvex_1_1Reductor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1plus.html">plus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary function object class whose call returns the result of adding its two arguments.  <a href="structvex_1_1plus.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1less.html">less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object class for less-than inequality comparison.  <a href="structvex_1_1less.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1less__equal.html">less_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object class for less-than-or-equal inequality comparison.  <a href="structvex_1_1less__equal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1greater.html">greater</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object class for greater-than inequality comparison.  <a href="structvex_1_1greater.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1greater__equal.html">greater_equal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function object class for greater-than-or-equal inequality comparison.  <a href="structvex_1_1greater__equal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1SpMatCCSR.html">SpMatCCSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix in CCSR format.  <a href="structvex_1_1SpMatCCSR.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMat.html">SpMat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix in hybrid ELL-CSR format.  <a href="classvex_1_1SpMat.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1stencil.html">stencil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil.  <a href="classvex_1_1stencil.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1StencilOperator.html">StencilOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined stencil operator.  <a href="classvex_1_1StencilOperator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device vector.  <a href="classvex_1_1vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1gslice.html">gslice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized slice selector.  <a href="structvex_1_1gslice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index range for use with slicer class.  <a href="structvex_1_1range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1slicer.html">slicer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slicing operator.  <a href="structvex_1_1slicer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f3700c5a3fd689cebd1c3301266b7ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a2f3700c5a3fd689cebd1c3301266b7ff">push_compile_options</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q, const std::string &amp;str)</td></tr>
<tr class="memdesc:a2f3700c5a3fd689cebd1c3301266b7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global compute kernel compilation options for a given device.  <a href="#a2f3700c5a3fd689cebd1c3301266b7ff">More...</a><br/></td></tr>
<tr class="separator:a2f3700c5a3fd689cebd1c3301266b7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07c402052137a80de67e1137f258341"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac07c402052137a80de67e1137f258341"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac07c402052137a80de67e1137f258341">pop_compile_options</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q)</td></tr>
<tr class="memdesc:ac07c402052137a80de67e1137f258341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options. <br/></td></tr>
<tr class="separator:ac07c402052137a80de67e1137f258341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16dc38863b68e8c2cd28a117044a3b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa16dc38863b68e8c2cd28a117044a3b6">push_program_header</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q, const std::string &amp;str)</td></tr>
<tr class="memdesc:aa16dc38863b68e8c2cd28a117044a3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global compute kernel header for a given device.  <a href="#aa16dc38863b68e8c2cd28a117044a3b6">More...</a><br/></td></tr>
<tr class="separator:aa16dc38863b68e8c2cd28a117044a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5371f8233d7cfed97b68e3126e860e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f5371f8233d7cfed97b68e3126e860e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1f5371f8233d7cfed97b68e3126e860e">pop_program_header</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q)</td></tr>
<tr class="memdesc:a1f5371f8233d7cfed97b68e3126e860e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options. <br/></td></tr>
<tr class="separator:a1f5371f8233d7cfed97b68e3126e860e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9db4bda4971c23090ce43eb9e578f65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9db4bda4971c23090ce43eb9e578f65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab9db4bda4971c23090ce43eb9e578f65">push_compile_options</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue, const std::string &amp;str)</td></tr>
<tr class="memdesc:ab9db4bda4971c23090ce43eb9e578f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global compute kernel compilation options for each device in queue list. <br/></td></tr>
<tr class="separator:ab9db4bda4971c23090ce43eb9e578f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87387b148e5f12d36cea89fdfb7a11cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87387b148e5f12d36cea89fdfb7a11cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a87387b148e5f12d36cea89fdfb7a11cd">pop_compile_options</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:a87387b148e5f12d36cea89fdfb7a11cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options for each device in queue list. <br/></td></tr>
<tr class="separator:a87387b148e5f12d36cea89fdfb7a11cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a560d2aca37d3493b5cdd4bd317e72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00a560d2aca37d3493b5cdd4bd317e72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a00a560d2aca37d3493b5cdd4bd317e72">push_program_header</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue, const std::string &amp;str)</td></tr>
<tr class="memdesc:a00a560d2aca37d3493b5cdd4bd317e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global OpenCL program header for each device in queue list. <br/></td></tr>
<tr class="separator:a00a560d2aca37d3493b5cdd4bd317e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d16252288166999a5494d04f35cf9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6d16252288166999a5494d04f35cf9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae6d16252288166999a5494d04f35cf9c">pop_program_header</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:ae6d16252288166999a5494d04f35cf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options for each device in queue list. <br/></td></tr>
<tr class="separator:ae6d16252288166999a5494d04f35cf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8327486578e0ab169174a502b8a7fe4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8327486578e0ab169174a502b8a7fe4"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa8327486578e0ab169174a502b8a7fe4">path_delim</a> ()</td></tr>
<tr class="memdesc:aa8327486578e0ab169174a502b8a7fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path delimiter symbol. <br/></td></tr>
<tr class="separator:aa8327486578e0ab169174a502b8a7fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5ead15e3e07a03b02228d137548be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f5ead15e3e07a03b02228d137548be7"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a0f5ead15e3e07a03b02228d137548be7">appdata_path</a> ()</td></tr>
<tr class="memdesc:a0f5ead15e3e07a03b02228d137548be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to appdata folder. <br/></td></tr>
<tr class="separator:a0f5ead15e3e07a03b02228d137548be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad813c378c0e17666ad73c9dd3ab504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ad813c378c0e17666ad73c9dd3ab504"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1ad813c378c0e17666ad73c9dd3ab504">program_binaries_path</a> (const std::string &amp;hash, bool create=false)</td></tr>
<tr class="memdesc:a1ad813c378c0e17666ad73c9dd3ab504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to cached binaries. <br/></td></tr>
<tr class="separator:a1ad813c378c0e17666ad73c9dd3ab504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dac744b63fbd08c03814bb6ab6ee81c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dac744b63fbd08c03814bb6ab6ee81c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a8dac744b63fbd08c03814bb6ab6ee81c">sha1</a> (const std::string &amp;src)</td></tr>
<tr class="memdesc:a8dac744b63fbd08c03814bb6ab6ee81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns SHA1 hash of the string parameter. <br/></td></tr>
<tr class="separator:a8dac744b63fbd08c03814bb6ab6ee81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9257e12cbac42bcd8cb21973b63cba"><td class="memTemplParams" colspan="2"><a class="anchor" id="aec9257e12cbac42bcd8cb21973b63cba"></a>
template&lt;typename T , class Expr &gt; </td></tr>
<tr class="memitem:aec9257e12cbac42bcd8cb21973b63cba"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; T, Expr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aec9257e12cbac42bcd8cb21973b63cba">cast</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:aec9257e12cbac42bcd8cb21973b63cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a given type. <br/></td></tr>
<tr class="separator:aec9257e12cbac42bcd8cb21973b63cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef4cdc828f667df6dd9ba17231a2586"><td class="memTemplParams" colspan="2"><a class="anchor" id="a2ef4cdc828f667df6dd9ba17231a2586"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a2ef4cdc828f667df6dd9ba17231a2586"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_float, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_float_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_float</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a2ef4cdc828f667df6dd9ba17231a2586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1c557bbab41dc6ddf7ec4c4a844b70"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7b1c557bbab41dc6ddf7ec4c4a844b70"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a7b1c557bbab41dc6ddf7ec4c4a844b70"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_float, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_float_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_float</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a7b1c557bbab41dc6ddf7ec4c4a844b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24ba61446643951a0377c283e19bfe5"><td class="memTemplParams" colspan="2"><a class="anchor" id="af24ba61446643951a0377c283e19bfe5"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af24ba61446643951a0377c283e19bfe5"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_float2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_float2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_float2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af24ba61446643951a0377c283e19bfe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4044862d43e1c94b05ee1598898e0865"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4044862d43e1c94b05ee1598898e0865"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a4044862d43e1c94b05ee1598898e0865"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_float2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_float2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_float2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a4044862d43e1c94b05ee1598898e0865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbd167b6efcff3ed50fe2554cb6ffb8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1dbd167b6efcff3ed50fe2554cb6ffb8"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a1dbd167b6efcff3ed50fe2554cb6ffb8"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_float4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_float4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_float4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a1dbd167b6efcff3ed50fe2554cb6ffb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fc788072025afe2c58565726ce9223"><td class="memTemplParams" colspan="2"><a class="anchor" id="a14fc788072025afe2c58565726ce9223"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a14fc788072025afe2c58565726ce9223"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_float4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_float4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_float4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a14fc788072025afe2c58565726ce9223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef1e06db53fa837fcafcf3075e5a4e6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaef1e06db53fa837fcafcf3075e5a4e6"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:aaef1e06db53fa837fcafcf3075e5a4e6"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_float8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_float8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_float8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:aaef1e06db53fa837fcafcf3075e5a4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05ef3db901a95d3f5bf93c663c9f674"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae05ef3db901a95d3f5bf93c663c9f674"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ae05ef3db901a95d3f5bf93c663c9f674"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_float8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_float8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_float8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ae05ef3db901a95d3f5bf93c663c9f674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ea9b4def872508bd1dafd7ed880a64"><td class="memTemplParams" colspan="2"><a class="anchor" id="a57ea9b4def872508bd1dafd7ed880a64"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a57ea9b4def872508bd1dafd7ed880a64"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_float16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_float16_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_float16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a57ea9b4def872508bd1dafd7ed880a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af195ac408caa5f43795a1bcf1432fc1e"><td class="memTemplParams" colspan="2"><a class="anchor" id="af195ac408caa5f43795a1bcf1432fc1e"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af195ac408caa5f43795a1bcf1432fc1e"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_float16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_float16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_float16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af195ac408caa5f43795a1bcf1432fc1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503ec13aa6ff2c905cb509440d71aed8"><td class="memTemplParams" colspan="2"><a class="anchor" id="a503ec13aa6ff2c905cb509440d71aed8"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a503ec13aa6ff2c905cb509440d71aed8"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_double, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_double_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_double</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a503ec13aa6ff2c905cb509440d71aed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530a21337407e4b4c1bed31b2feea3d1"><td class="memTemplParams" colspan="2"><a class="anchor" id="a530a21337407e4b4c1bed31b2feea3d1"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a530a21337407e4b4c1bed31b2feea3d1"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_double, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_double_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_double</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a530a21337407e4b4c1bed31b2feea3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b8cd4e5f65a7af81974d0e36903064"><td class="memTemplParams" colspan="2"><a class="anchor" id="a96b8cd4e5f65a7af81974d0e36903064"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a96b8cd4e5f65a7af81974d0e36903064"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_double2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_double2_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_double2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a96b8cd4e5f65a7af81974d0e36903064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9ff61361763924cadee23e75d9943b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0e9ff61361763924cadee23e75d9943b"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a0e9ff61361763924cadee23e75d9943b"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_double2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_double2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_double2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a0e9ff61361763924cadee23e75d9943b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a3ca39e33970ec6359a1e51d0fd764"><td class="memTemplParams" colspan="2"><a class="anchor" id="a41a3ca39e33970ec6359a1e51d0fd764"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a41a3ca39e33970ec6359a1e51d0fd764"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_double4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_double4_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_double4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a41a3ca39e33970ec6359a1e51d0fd764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d8eff4f40f40703106be172264a3c5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad0d8eff4f40f40703106be172264a3c5"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ad0d8eff4f40f40703106be172264a3c5"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_double4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_double4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_double4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ad0d8eff4f40f40703106be172264a3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371dc17f4d01e1aeb676f613fa8c01d4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a371dc17f4d01e1aeb676f613fa8c01d4"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a371dc17f4d01e1aeb676f613fa8c01d4"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_double8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_double8_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_double8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a371dc17f4d01e1aeb676f613fa8c01d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514f40c71b5ae9d0b59efbef4cec2570"><td class="memTemplParams" colspan="2"><a class="anchor" id="a514f40c71b5ae9d0b59efbef4cec2570"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a514f40c71b5ae9d0b59efbef4cec2570"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_double8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_double8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_double8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a514f40c71b5ae9d0b59efbef4cec2570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd287dcab42ff9b1e5e4f2898065428"><td class="memTemplParams" colspan="2"><a class="anchor" id="affd287dcab42ff9b1e5e4f2898065428"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:affd287dcab42ff9b1e5e4f2898065428"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_double16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_double16_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_double16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:affd287dcab42ff9b1e5e4f2898065428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7420e53ad68ecaf1bd9ae6a324dada5"><td class="memTemplParams" colspan="2"><a class="anchor" id="af7420e53ad68ecaf1bd9ae6a324dada5"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af7420e53ad68ecaf1bd9ae6a324dada5"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_double16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_double16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_double16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af7420e53ad68ecaf1bd9ae6a324dada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8875c27068943c2d6b10e8991f6874ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8875c27068943c2d6b10e8991f6874ff"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a8875c27068943c2d6b10e8991f6874ff"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_char, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_char_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_char</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a8875c27068943c2d6b10e8991f6874ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1337f416b03b6adef7b95cb2f0b82cbf"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1337f416b03b6adef7b95cb2f0b82cbf"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a1337f416b03b6adef7b95cb2f0b82cbf"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_char, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_char_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_char</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a1337f416b03b6adef7b95cb2f0b82cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83bf8e2abf384c66cbf2f150501e923d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a83bf8e2abf384c66cbf2f150501e923d"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a83bf8e2abf384c66cbf2f150501e923d"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_char2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_char2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_char2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a83bf8e2abf384c66cbf2f150501e923d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab542a6c1e03f9c68cc1bf7c23387c9d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab542a6c1e03f9c68cc1bf7c23387c9d"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:aab542a6c1e03f9c68cc1bf7c23387c9d"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_char2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_char2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_char2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:aab542a6c1e03f9c68cc1bf7c23387c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb4b0a6e854d96793d962771831b8a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="afcb4b0a6e854d96793d962771831b8a4"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:afcb4b0a6e854d96793d962771831b8a4"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_char4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_char4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_char4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:afcb4b0a6e854d96793d962771831b8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f333770f08e7a91b4bac0e2dca2f84"><td class="memTemplParams" colspan="2"><a class="anchor" id="a01f333770f08e7a91b4bac0e2dca2f84"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a01f333770f08e7a91b4bac0e2dca2f84"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_char4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_char4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_char4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a01f333770f08e7a91b4bac0e2dca2f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6514e2b7b5ca7fb1fcaee20dfb300500"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6514e2b7b5ca7fb1fcaee20dfb300500"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a6514e2b7b5ca7fb1fcaee20dfb300500"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_char8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_char8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_char8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a6514e2b7b5ca7fb1fcaee20dfb300500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd94fe40e88638a5c3790970216e022"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5fd94fe40e88638a5c3790970216e022"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a5fd94fe40e88638a5c3790970216e022"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_char8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_char8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_char8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a5fd94fe40e88638a5c3790970216e022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a81d388ffd97fa6634accb67f495d3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a40a81d388ffd97fa6634accb67f495d3"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a40a81d388ffd97fa6634accb67f495d3"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_char16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_char16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_char16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a40a81d388ffd97fa6634accb67f495d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e1f8f59b57a08696e9c72a49823089"><td class="memTemplParams" colspan="2"><a class="anchor" id="a76e1f8f59b57a08696e9c72a49823089"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a76e1f8f59b57a08696e9c72a49823089"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_char16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_char16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_char16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a76e1f8f59b57a08696e9c72a49823089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e230c441627d635449ca4ee77d3292"><td class="memTemplParams" colspan="2"><a class="anchor" id="a66e230c441627d635449ca4ee77d3292"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a66e230c441627d635449ca4ee77d3292"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uchar, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_uchar_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_uchar</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a66e230c441627d635449ca4ee77d3292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42996fa65f1da656707b4e6a252129e9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a42996fa65f1da656707b4e6a252129e9"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a42996fa65f1da656707b4e6a252129e9"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uchar, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_uchar_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_uchar</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a42996fa65f1da656707b4e6a252129e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53994b1826e4d77f38541b942e0312a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a53994b1826e4d77f38541b942e0312a9"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a53994b1826e4d77f38541b942e0312a9"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uchar2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_uchar2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_uchar2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a53994b1826e4d77f38541b942e0312a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af791b1c239e5533ee073957eabac5890"><td class="memTemplParams" colspan="2"><a class="anchor" id="af791b1c239e5533ee073957eabac5890"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af791b1c239e5533ee073957eabac5890"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uchar2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_uchar2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_uchar2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af791b1c239e5533ee073957eabac5890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64bc15d58c68c7ad436e385b8d6924c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae64bc15d58c68c7ad436e385b8d6924c"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ae64bc15d58c68c7ad436e385b8d6924c"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uchar4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_uchar4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_uchar4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ae64bc15d58c68c7ad436e385b8d6924c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef582a7af8a53597fdcdfbf2034bd43e"><td class="memTemplParams" colspan="2"><a class="anchor" id="aef582a7af8a53597fdcdfbf2034bd43e"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:aef582a7af8a53597fdcdfbf2034bd43e"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uchar4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_uchar4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_uchar4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:aef582a7af8a53597fdcdfbf2034bd43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1a9791a56cec975d8be5fc09e66d19"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8a1a9791a56cec975d8be5fc09e66d19"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a8a1a9791a56cec975d8be5fc09e66d19"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uchar8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_uchar8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_uchar8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a8a1a9791a56cec975d8be5fc09e66d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c96e8ddb00f89f5a21895ecd7a6204"><td class="memTemplParams" colspan="2"><a class="anchor" id="a49c96e8ddb00f89f5a21895ecd7a6204"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a49c96e8ddb00f89f5a21895ecd7a6204"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uchar8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_uchar8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_uchar8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a49c96e8ddb00f89f5a21895ecd7a6204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add63d7aad24b9680b2c48448151d52fc"><td class="memTemplParams" colspan="2"><a class="anchor" id="add63d7aad24b9680b2c48448151d52fc"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:add63d7aad24b9680b2c48448151d52fc"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uchar16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_uchar16_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_uchar16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:add63d7aad24b9680b2c48448151d52fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5355748f7373e5d3b11941bdf5393ed5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5355748f7373e5d3b11941bdf5393ed5"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a5355748f7373e5d3b11941bdf5393ed5"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uchar16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_uchar16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_uchar16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a5355748f7373e5d3b11941bdf5393ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068e74364c24ab788d0c5265357adb68"><td class="memTemplParams" colspan="2"><a class="anchor" id="a068e74364c24ab788d0c5265357adb68"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a068e74364c24ab788d0c5265357adb68"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_short, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_short_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_short</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a068e74364c24ab788d0c5265357adb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb6a6e85f308cf8269043af3d561028"><td class="memTemplParams" colspan="2"><a class="anchor" id="acbb6a6e85f308cf8269043af3d561028"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:acbb6a6e85f308cf8269043af3d561028"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_short, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_short_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_short</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:acbb6a6e85f308cf8269043af3d561028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf59f98ade66e8deab49e2b3aa43129d"><td class="memTemplParams" colspan="2"><a class="anchor" id="adf59f98ade66e8deab49e2b3aa43129d"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:adf59f98ade66e8deab49e2b3aa43129d"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_short2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_short2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_short2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:adf59f98ade66e8deab49e2b3aa43129d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a311cf322dfde746dfebb82084fe9a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a41a311cf322dfde746dfebb82084fe9a"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a41a311cf322dfde746dfebb82084fe9a"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_short2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_short2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_short2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a41a311cf322dfde746dfebb82084fe9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837e6757f08fc3480a59dcdda44eb1b4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a837e6757f08fc3480a59dcdda44eb1b4"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a837e6757f08fc3480a59dcdda44eb1b4"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_short4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_short4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_short4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a837e6757f08fc3480a59dcdda44eb1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6998383ca969bad6e585b9d455a2042"><td class="memTemplParams" colspan="2"><a class="anchor" id="af6998383ca969bad6e585b9d455a2042"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af6998383ca969bad6e585b9d455a2042"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_short4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_short4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_short4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af6998383ca969bad6e585b9d455a2042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7dc7dc9446d234d006d59492f602c10"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab7dc7dc9446d234d006d59492f602c10"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ab7dc7dc9446d234d006d59492f602c10"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_short8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_short8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_short8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ab7dc7dc9446d234d006d59492f602c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93859bb904992ac94756d9f4b411a991"><td class="memTemplParams" colspan="2"><a class="anchor" id="a93859bb904992ac94756d9f4b411a991"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a93859bb904992ac94756d9f4b411a991"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_short8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_short8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_short8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a93859bb904992ac94756d9f4b411a991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abddfc58ff6b32588f61bb28b3478be"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3abddfc58ff6b32588f61bb28b3478be"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a3abddfc58ff6b32588f61bb28b3478be"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_short16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_short16_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_short16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a3abddfc58ff6b32588f61bb28b3478be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade63a92527fde2b8dace1333e2206222"><td class="memTemplParams" colspan="2"><a class="anchor" id="ade63a92527fde2b8dace1333e2206222"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ade63a92527fde2b8dace1333e2206222"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_short16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_short16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_short16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ade63a92527fde2b8dace1333e2206222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b6007f219cb56e102fb03be2cc90a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a78b6007f219cb56e102fb03be2cc90a4"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a78b6007f219cb56e102fb03be2cc90a4"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ushort, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_ushort_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_ushort</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a78b6007f219cb56e102fb03be2cc90a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a488cdd9b829c88706f1358d20c560e24"><td class="memTemplParams" colspan="2"><a class="anchor" id="a488cdd9b829c88706f1358d20c560e24"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a488cdd9b829c88706f1358d20c560e24"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ushort, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_ushort_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_ushort</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a488cdd9b829c88706f1358d20c560e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60d1916ec7cff341c80f620ba20200b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab60d1916ec7cff341c80f620ba20200b"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ab60d1916ec7cff341c80f620ba20200b"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ushort2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_ushort2_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_ushort2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ab60d1916ec7cff341c80f620ba20200b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4bdf1f8a36bcab5acb07fc8839d6678"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae4bdf1f8a36bcab5acb07fc8839d6678"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ae4bdf1f8a36bcab5acb07fc8839d6678"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ushort2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_ushort2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_ushort2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ae4bdf1f8a36bcab5acb07fc8839d6678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad97929a1d4af46eebd353b11dda4c4b6"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad97929a1d4af46eebd353b11dda4c4b6"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ad97929a1d4af46eebd353b11dda4c4b6"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ushort4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_ushort4_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_ushort4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ad97929a1d4af46eebd353b11dda4c4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ca9de19918efc23e7092bfa9d5aafe"><td class="memTemplParams" colspan="2"><a class="anchor" id="af8ca9de19918efc23e7092bfa9d5aafe"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af8ca9de19918efc23e7092bfa9d5aafe"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ushort4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_ushort4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_ushort4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af8ca9de19918efc23e7092bfa9d5aafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f8d9d9fe2490bc7cd86360d4aaf657"><td class="memTemplParams" colspan="2"><a class="anchor" id="af5f8d9d9fe2490bc7cd86360d4aaf657"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af5f8d9d9fe2490bc7cd86360d4aaf657"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ushort8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_ushort8_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_ushort8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af5f8d9d9fe2490bc7cd86360d4aaf657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb1e315d6327d729eac330ffb663fe4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0eb1e315d6327d729eac330ffb663fe4"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a0eb1e315d6327d729eac330ffb663fe4"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ushort8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_ushort8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_ushort8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a0eb1e315d6327d729eac330ffb663fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c67c5028dd83069d7a558b99b824619"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1c67c5028dd83069d7a558b99b824619"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a1c67c5028dd83069d7a558b99b824619"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ushort16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_ushort16_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_ushort16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a1c67c5028dd83069d7a558b99b824619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae985961752f630751ef7074024e5e1bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae985961752f630751ef7074024e5e1bb"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ae985961752f630751ef7074024e5e1bb"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ushort16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_ushort16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_ushort16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ae985961752f630751ef7074024e5e1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6ae3a665b19d131637fea28dd54078"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9b6ae3a665b19d131637fea28dd54078"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a9b6ae3a665b19d131637fea28dd54078"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_int, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_int_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_int</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a9b6ae3a665b19d131637fea28dd54078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9218cd2cd694f9d8f5eb690cdb898a0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9218cd2cd694f9d8f5eb690cdb898a0e"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a9218cd2cd694f9d8f5eb690cdb898a0e"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_int, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_int_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_int</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a9218cd2cd694f9d8f5eb690cdb898a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ef41ae1923044565b728d1cdb7b1bb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae4ef41ae1923044565b728d1cdb7b1bb"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ae4ef41ae1923044565b728d1cdb7b1bb"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_int2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_int2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_int2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ae4ef41ae1923044565b728d1cdb7b1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff78d241e43a18ea557b4f4fac10729"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7ff78d241e43a18ea557b4f4fac10729"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a7ff78d241e43a18ea557b4f4fac10729"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_int2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_int2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_int2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a7ff78d241e43a18ea557b4f4fac10729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98aea43c654e205ca2aa5bcfd1528e2b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a98aea43c654e205ca2aa5bcfd1528e2b"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a98aea43c654e205ca2aa5bcfd1528e2b"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_int4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_int4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_int4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a98aea43c654e205ca2aa5bcfd1528e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af468e00fb1bda176a127e1ec9551be31"><td class="memTemplParams" colspan="2"><a class="anchor" id="af468e00fb1bda176a127e1ec9551be31"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af468e00fb1bda176a127e1ec9551be31"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_int4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_int4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_int4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af468e00fb1bda176a127e1ec9551be31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f50b8f92d6324ee140ab6eeebdff539"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5f50b8f92d6324ee140ab6eeebdff539"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a5f50b8f92d6324ee140ab6eeebdff539"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_int8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_int8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_int8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a5f50b8f92d6324ee140ab6eeebdff539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397deb0ff6fdb1bdd5ed08b2a2d33c69"><td class="memTemplParams" colspan="2"><a class="anchor" id="a397deb0ff6fdb1bdd5ed08b2a2d33c69"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a397deb0ff6fdb1bdd5ed08b2a2d33c69"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_int8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_int8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_int8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a397deb0ff6fdb1bdd5ed08b2a2d33c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac180843370deb172453e8c9840b7b75"><td class="memTemplParams" colspan="2"><a class="anchor" id="aac180843370deb172453e8c9840b7b75"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:aac180843370deb172453e8c9840b7b75"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_int16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_int16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_int16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:aac180843370deb172453e8c9840b7b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf200ccc095302ea7a978d582daffde"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1cf200ccc095302ea7a978d582daffde"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a1cf200ccc095302ea7a978d582daffde"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_int16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_int16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_int16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a1cf200ccc095302ea7a978d582daffde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf8ce19b312b339c8bdc38ce586e99c"><td class="memTemplParams" colspan="2"><a class="anchor" id="abaf8ce19b312b339c8bdc38ce586e99c"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:abaf8ce19b312b339c8bdc38ce586e99c"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uint, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_uint_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_uint</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:abaf8ce19b312b339c8bdc38ce586e99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d06c3c9e1b31e5a95f510493cd3e0f9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6d06c3c9e1b31e5a95f510493cd3e0f9"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a6d06c3c9e1b31e5a95f510493cd3e0f9"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uint, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_uint_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_uint</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a6d06c3c9e1b31e5a95f510493cd3e0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729ccc16227fe62f92920146bf5a9809"><td class="memTemplParams" colspan="2"><a class="anchor" id="a729ccc16227fe62f92920146bf5a9809"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a729ccc16227fe62f92920146bf5a9809"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uint2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_uint2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_uint2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a729ccc16227fe62f92920146bf5a9809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734a594632e67f22f5a7d1aeb131616d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a734a594632e67f22f5a7d1aeb131616d"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a734a594632e67f22f5a7d1aeb131616d"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uint2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_uint2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_uint2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a734a594632e67f22f5a7d1aeb131616d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0afcce2021470fbe6d0aa26080894b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f0afcce2021470fbe6d0aa26080894b"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a7f0afcce2021470fbe6d0aa26080894b"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uint4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_uint4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_uint4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a7f0afcce2021470fbe6d0aa26080894b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5bf036412b68ccf548f93be3234ddb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a9d5bf036412b68ccf548f93be3234ddb"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a9d5bf036412b68ccf548f93be3234ddb"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uint4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_uint4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_uint4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a9d5bf036412b68ccf548f93be3234ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc12dc02ce7896e74a0fe8d4c5c9c3a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8fc12dc02ce7896e74a0fe8d4c5c9c3a"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a8fc12dc02ce7896e74a0fe8d4c5c9c3a"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uint8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_uint8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_uint8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a8fc12dc02ce7896e74a0fe8d4c5c9c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f7780de415dd4c41720432114605eb"><td class="memTemplParams" colspan="2"><a class="anchor" id="a34f7780de415dd4c41720432114605eb"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a34f7780de415dd4c41720432114605eb"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uint8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_uint8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_uint8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a34f7780de415dd4c41720432114605eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ce0c16060c06e869642b4ed3e6f69a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a56ce0c16060c06e869642b4ed3e6f69a"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a56ce0c16060c06e869642b4ed3e6f69a"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uint16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_uint16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_uint16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a56ce0c16060c06e869642b4ed3e6f69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25841c1d3afa65292379c2b064106943"><td class="memTemplParams" colspan="2"><a class="anchor" id="a25841c1d3afa65292379c2b064106943"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a25841c1d3afa65292379c2b064106943"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_uint16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_uint16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_uint16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a25841c1d3afa65292379c2b064106943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d093dfae089eeb01662d359a3a92a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a78d093dfae089eeb01662d359a3a92a5"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a78d093dfae089eeb01662d359a3a92a5"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_long, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_long_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_long</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a78d093dfae089eeb01662d359a3a92a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c03a0fc5d3012f42d8d2eacf5e2cef"><td class="memTemplParams" colspan="2"><a class="anchor" id="a38c03a0fc5d3012f42d8d2eacf5e2cef"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a38c03a0fc5d3012f42d8d2eacf5e2cef"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_long, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_long_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_long</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a38c03a0fc5d3012f42d8d2eacf5e2cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1711ebe62728f71e7756102965665c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1d1711ebe62728f71e7756102965665c"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a1d1711ebe62728f71e7756102965665c"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_long2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_long2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_long2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a1d1711ebe62728f71e7756102965665c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433b65045b962279d03a4375f37c9cb7"><td class="memTemplParams" colspan="2"><a class="anchor" id="a433b65045b962279d03a4375f37c9cb7"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a433b65045b962279d03a4375f37c9cb7"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_long2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_long2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_long2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a433b65045b962279d03a4375f37c9cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a4aaeb21540d3435956fd79f78c731"><td class="memTemplParams" colspan="2"><a class="anchor" id="a02a4aaeb21540d3435956fd79f78c731"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a02a4aaeb21540d3435956fd79f78c731"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_long4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_long4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_long4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a02a4aaeb21540d3435956fd79f78c731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b99bc949b54c03d74f14a8b628bd39"><td class="memTemplParams" colspan="2"><a class="anchor" id="a67b99bc949b54c03d74f14a8b628bd39"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a67b99bc949b54c03d74f14a8b628bd39"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_long4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_long4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_long4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a67b99bc949b54c03d74f14a8b628bd39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e4b16e9e5c1e4d24eb3ece360bda12"><td class="memTemplParams" colspan="2"><a class="anchor" id="a55e4b16e9e5c1e4d24eb3ece360bda12"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a55e4b16e9e5c1e4d24eb3ece360bda12"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_long8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_long8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_long8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a55e4b16e9e5c1e4d24eb3ece360bda12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef43fb93f9eb517c771c30a7d0e491d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a3ef43fb93f9eb517c771c30a7d0e491d"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a3ef43fb93f9eb517c771c30a7d0e491d"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_long8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_long8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_long8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a3ef43fb93f9eb517c771c30a7d0e491d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352087a38a745a377c5a9bd38c0139bd"><td class="memTemplParams" colspan="2"><a class="anchor" id="a352087a38a745a377c5a9bd38c0139bd"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a352087a38a745a377c5a9bd38c0139bd"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_long16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_long16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_long16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a352087a38a745a377c5a9bd38c0139bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5020f5432acca0f88211e91201ba7783"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5020f5432acca0f88211e91201ba7783"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a5020f5432acca0f88211e91201ba7783"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_long16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_long16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_long16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a5020f5432acca0f88211e91201ba7783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52ed6126ff663d4ca86ea476b9c7642"><td class="memTemplParams" colspan="2"><a class="anchor" id="af52ed6126ff663d4ca86ea476b9c7642"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af52ed6126ff663d4ca86ea476b9c7642"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ulong, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_ulong_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_ulong</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af52ed6126ff663d4ca86ea476b9c7642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf4f0b8e8a355bbbaad8212e13bd81b"><td class="memTemplParams" colspan="2"><a class="anchor" id="afcf4f0b8e8a355bbbaad8212e13bd81b"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:afcf4f0b8e8a355bbbaad8212e13bd81b"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ulong, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_ulong_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_ulong</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:afcf4f0b8e8a355bbbaad8212e13bd81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16297f17404b59419d0eac11356946da"><td class="memTemplParams" colspan="2"><a class="anchor" id="a16297f17404b59419d0eac11356946da"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a16297f17404b59419d0eac11356946da"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ulong2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_ulong2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_ulong2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a16297f17404b59419d0eac11356946da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a454d6ff272ef1a23773a78599f9109"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1a454d6ff272ef1a23773a78599f9109"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a1a454d6ff272ef1a23773a78599f9109"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ulong2, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_ulong2_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_ulong2</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a1a454d6ff272ef1a23773a78599f9109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17f9dccc36001ca3d167ba818c8bb93"><td class="memTemplParams" colspan="2"><a class="anchor" id="af17f9dccc36001ca3d167ba818c8bb93"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af17f9dccc36001ca3d167ba818c8bb93"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ulong4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_ulong4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_ulong4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af17f9dccc36001ca3d167ba818c8bb93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829a73009cf33314082a6161a545efb0"><td class="memTemplParams" colspan="2"><a class="anchor" id="a829a73009cf33314082a6161a545efb0"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a829a73009cf33314082a6161a545efb0"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ulong4, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_ulong4_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_ulong4</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a829a73009cf33314082a6161a545efb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab766981dfc2a474481f8342f2cd2e59e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab766981dfc2a474481f8342f2cd2e59e"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:ab766981dfc2a474481f8342f2cd2e59e"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ulong8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_ulong8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_ulong8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:ab766981dfc2a474481f8342f2cd2e59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651066c914435cdf70ce61b3a36fcaa3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a651066c914435cdf70ce61b3a36fcaa3"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a651066c914435cdf70ce61b3a36fcaa3"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ulong8, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_ulong8_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_ulong8</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a651066c914435cdf70ce61b3a36fcaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52e82562200448397374dfeb2738984"><td class="memTemplParams" colspan="2"><a class="anchor" id="af52e82562200448397374dfeb2738984"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:af52e82562200448397374dfeb2738984"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ulong16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
convert_ulong16_func, const <br class="typebreak"/>
Arg &amp; &gt;::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convert_ulong16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:af52e82562200448397374dfeb2738984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4569a2a9b476a7cd67b33beb84314be3"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4569a2a9b476a7cd67b33beb84314be3"></a>
template&lt;typename Arg &gt; </td></tr>
<tr class="memitem:a4569a2a9b476a7cd67b33beb84314be3"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; cl_ulong16, <br class="typebreak"/>
typename <br class="typebreak"/>
boost::proto::result_of::make_expr<br class="typebreak"/>
&lt; boost::proto::tag::function, <br class="typebreak"/>
as_ulong16_func, const Arg &amp; &gt;<br class="typebreak"/>
::type &gt; const&#160;</td><td class="memTemplItemRight" valign="bottom"><b>as_ulong16</b> (const Arg &amp;arg)</td></tr>
<tr class="separator:a4569a2a9b476a7cd67b33beb84314be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f952de6aa067cc2e34ef16e91429e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78f952de6aa067cc2e34ef16e91429e7"></a>
const <a class="el" href="classvex_1_1Context.html">Context</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a78f952de6aa067cc2e34ef16e91429e7">current_context</a> ()</td></tr>
<tr class="memdesc:a78f952de6aa067cc2e34ef16e91429e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reference to the latest instance of <a class="el" href="classvex_1_1Context.html" title="VexCL context holder. ">vex::Context</a>. <br/></td></tr>
<tr class="separator:a78f952de6aa067cc2e34ef16e91429e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf35349b5accc05f96b291457f522acb"><td class="memItemLeft" align="right" valign="top">elem_index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#acf35349b5accc05f96b291457f522acb">element_index</a> (size_t offset=0, size_t length=0)</td></tr>
<tr class="memdesc:acf35349b5accc05f96b291457f522acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">When used in vector expression, returns current element index plus offset.  <a href="#acf35349b5accc05f96b291457f522acb">More...</a><br/></td></tr>
<tr class="separator:acf35349b5accc05f96b291457f522acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017d6f5c75fa02d04dc5e4eef993978d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a017d6f5c75fa02d04dc5e4eef993978d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a017d6f5c75fa02d04dc5e4eef993978d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a017d6f5c75fa02d04dc5e4eef993978d">inclusive_scan</a> (const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;src, <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dst)</td></tr>
<tr class="memdesc:a017d6f5c75fa02d04dc5e4eef993978d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inclusive scan. <br/></td></tr>
<tr class="separator:a017d6f5c75fa02d04dc5e4eef993978d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee2afe5ab14567e3900ecea19e46c78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ee2afe5ab14567e3900ecea19e46c78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a0ee2afe5ab14567e3900ecea19e46c78">sort</a> (<a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a0ee2afe5ab14567e3900ecea19e46c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort.  <a href="#a0ee2afe5ab14567e3900ecea19e46c78">More...</a><br/></td></tr>
<tr class="separator:a0ee2afe5ab14567e3900ecea19e46c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a309be2ac9197a3a1f16c3f58da32e4a5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a309be2ac9197a3a1f16c3f58da32e4a5">operator&lt;&lt;</a> (std::ostream &amp;os, const symbolic&lt; T &gt; &amp;sym)</td></tr>
<tr class="memdesc:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends name of the symbolic variable to output stream. <br/></td></tr>
<tr class="separator:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f2a40c6b7a0f4b540ba12f2b52532b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab9f2a40c6b7a0f4b540ba12f2b52532b"></a>
template&lt;class RDC , typename T , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:ab9f2a40c6b7a0f4b540ba12f2b52532b"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt;<br class="typebreak"/>
, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab9f2a40c6b7a0f4b540ba12f2b52532b">reduce</a> (const multi_array&lt; T, NDIM &gt; &amp;m, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:ab9f2a40c6b7a0f4b540ba12f2b52532b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vex::multi_array along the specified dimensions. <br/></td></tr>
<tr class="separator:ab9f2a40c6b7a0f4b540ba12f2b52532b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af475f0b6dadddfa0df505b5be6555fe6"><td class="memTemplParams" colspan="2"><a class="anchor" id="af475f0b6dadddfa0df505b5be6555fe6"></a>
template&lt;class RDC , typename T , size_t NDIM&gt; </td></tr>
<tr class="memitem:af475f0b6dadddfa0df505b5be6555fe6"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt;<br class="typebreak"/>
, NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#af475f0b6dadddfa0df505b5be6555fe6">reduce</a> (const multi_array&lt; T, NDIM &gt; &amp;m, size_t reduce_dim)</td></tr>
<tr class="memdesc:af475f0b6dadddfa0df505b5be6555fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vex::multi_array along the specified dimension. <br/></td></tr>
<tr class="separator:af475f0b6dadddfa0df505b5be6555fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa68b032f0d66695e3b3b6c5375e8cf6"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aaa68b032f0d66695e3b3b6c5375e8cf6">copy</a> (const <a class="el" href="classvex_1_1multivector.html">multivector</a>&lt; T, N &gt; &amp;mv, std::vector&lt; T &gt; &amp;hv)</td></tr>
<tr class="memdesc:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy multivector to host vector. <br/></td></tr>
<tr class="separator:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11afb8e8e5387abf04e3b7f815111e0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11afb8e8e5387abf04e3b7f815111e0e"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a11afb8e8e5387abf04e3b7f815111e0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a11afb8e8e5387abf04e3b7f815111e0e">copy</a> (const std::vector&lt; T &gt; &amp;hv, <a class="el" href="classvex_1_1multivector.html">multivector</a>&lt; T, N &gt; &amp;mv)</td></tr>
<tr class="memdesc:a11afb8e8e5387abf04e3b7f815111e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host vector to multivector. <br/></td></tr>
<tr class="separator:a11afb8e8e5387abf04e3b7f815111e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8aaad637ee6e4c8527222b58ddd1089"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab8aaad637ee6e4c8527222b58ddd1089"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:ab8aaad637ee6e4c8527222b58ddd1089"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab8aaad637ee6e4c8527222b58ddd1089">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classvex_1_1multivector.html">vex::multivector</a>&lt; T, N &gt; &amp;t)</td></tr>
<tr class="memdesc:ab8aaad637ee6e4c8527222b58ddd1089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download and print the vector elements. <br/></td></tr>
<tr class="separator:ab8aaad637ee6e4c8527222b58ddd1089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ed95396644bcef1aff9a0cac89e69a"><td class="memTemplParams" colspan="2">template&lt;class... Expr&gt; </td></tr>
<tr class="memitem:ab7ed95396644bcef1aff9a0cac89e69a"><td class="memTemplItemLeft" align="right" valign="top">expression_tuple&lt; std::tuple<br class="typebreak"/>
&lt; const Expr &amp;...&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab7ed95396644bcef1aff9a0cac89e69a">tie</a> (const Expr &amp;...expr)</td></tr>
<tr class="memdesc:ab7ed95396644bcef1aff9a0cac89e69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ties several vector expressions into writeable tuple.  <a href="#ab7ed95396644bcef1aff9a0cac89e69a">More...</a><br/></td></tr>
<tr class="separator:ab7ed95396644bcef1aff9a0cac89e69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ec79ec8d6883b9541de849f531772"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b8ec79ec8d6883b9541de849f531772"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a5b8ec79ec8d6883b9541de849f531772">purge_kernel_caches</a> ()</td></tr>
<tr class="memdesc:a5b8ec79ec8d6883b9541de849f531772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached OpenCL kernels, allowing to release OpenCL contexts. <br/></td></tr>
<tr class="separator:a5b8ec79ec8d6883b9541de849f531772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563d351840b2719958e17a653d7ad922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a563d351840b2719958e17a653d7ad922"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a563d351840b2719958e17a653d7ad922">purge_kernel_caches</a> (backend::kernel_cache_key key)</td></tr>
<tr class="memdesc:a563d351840b2719958e17a653d7ad922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached OpenCL kernels, allowing to release OpenCL contexts. <br/></td></tr>
<tr class="separator:a563d351840b2719958e17a653d7ad922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1670e7948b19b0c6fbcedc816ee70632"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1670e7948b19b0c6fbcedc816ee70632"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1670e7948b19b0c6fbcedc816ee70632">purge_kernel_caches</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:a1670e7948b19b0c6fbcedc816ee70632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached OpenCL kernels, allowing to release OpenCL contexts. <br/></td></tr>
<tr class="separator:a1670e7948b19b0c6fbcedc816ee70632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2218b98674ff19fb08a82842a0a5646"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2218b98674ff19fb08a82842a0a5646"></a>
template&lt;typename IKeys , typename OKeys , typename V , class Comp , class Oper &gt; </td></tr>
<tr class="memitem:aa2218b98674ff19fb08a82842a0a5646"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa2218b98674ff19fb08a82842a0a5646">reduce_by_key</a> (IKeys &amp;&amp;ikeys, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; const &amp;ivals, OKeys &amp;&amp;okeys, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ovals, Comp comp, Oper oper)</td></tr>
<tr class="memdesc:aa2218b98674ff19fb08a82842a0a5646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce by key algorithm. <br/></td></tr>
<tr class="separator:aa2218b98674ff19fb08a82842a0a5646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae253d3b2dd8a5fd26a14dec81d8a51c2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ae253d3b2dd8a5fd26a14dec81d8a51c2"></a>
template&lt;typename K , typename V &gt; </td></tr>
<tr class="memitem:ae253d3b2dd8a5fd26a14dec81d8a51c2"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae253d3b2dd8a5fd26a14dec81d8a51c2">reduce_by_key</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; K &gt; const &amp;ikeys, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; const &amp;ivals, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; K &gt; &amp;okeys, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;ovals)</td></tr>
<tr class="memdesc:ae253d3b2dd8a5fd26a14dec81d8a51c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce by key algorithm. <br/></td></tr>
<tr class="separator:ae253d3b2dd8a5fd26a14dec81d8a51c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8f8c0901de2d0e5e99605d10b30fb6"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe8f8c0901de2d0e5e99605d10b30fb6"></a>
template&lt;typename T , class R &gt; </td></tr>
<tr class="memitem:abe8f8c0901de2d0e5e99605d10b30fb6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1Reductor.html">vex::Reductor</a>&lt; T, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#abe8f8c0901de2d0e5e99605d10b30fb6">get_reductor</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:abe8f8c0901de2d0e5e99605d10b30fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a static instance of vex::Reductor&lt;T,R&gt; <br/></td></tr>
<tr class="separator:abe8f8c0901de2d0e5e99605d10b30fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc18f46eb80f11430bd7d1fd224e4df"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8fc18f46eb80f11430bd7d1fd224e4df"></a>
template&lt;typename T , class Oper &gt; </td></tr>
<tr class="memitem:a8fc18f46eb80f11430bd7d1fd224e4df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a8fc18f46eb80f11430bd7d1fd224e4df">inclusive_scan</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; const &amp;input, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;output, T init, Oper oper)</td></tr>
<tr class="memdesc:a8fc18f46eb80f11430bd7d1fd224e4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inclusive scan. <br/></td></tr>
<tr class="separator:a8fc18f46eb80f11430bd7d1fd224e4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536ee0effdd0c81b2252ddf7bf0cb3a9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a536ee0effdd0c81b2252ddf7bf0cb3a9"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a536ee0effdd0c81b2252ddf7bf0cb3a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a536ee0effdd0c81b2252ddf7bf0cb3a9">inclusive_scan</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; const &amp;input, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;output, T init=T())</td></tr>
<tr class="memdesc:a536ee0effdd0c81b2252ddf7bf0cb3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inclusive scan. <br/></td></tr>
<tr class="separator:a536ee0effdd0c81b2252ddf7bf0cb3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d36c4ddd6b769349ebb2c11badf2199"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4d36c4ddd6b769349ebb2c11badf2199"></a>
template&lt;typename T , class Oper &gt; </td></tr>
<tr class="memitem:a4d36c4ddd6b769349ebb2c11badf2199"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a4d36c4ddd6b769349ebb2c11badf2199">exclusive_scan</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; const &amp;input, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;output, T init, Oper oper)</td></tr>
<tr class="memdesc:a4d36c4ddd6b769349ebb2c11badf2199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exclusive scan. <br/></td></tr>
<tr class="separator:a4d36c4ddd6b769349ebb2c11badf2199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523b47ce4da35257c05e7d509e69db2d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a523b47ce4da35257c05e7d509e69db2d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a523b47ce4da35257c05e7d509e69db2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a523b47ce4da35257c05e7d509e69db2d">exclusive_scan</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; const &amp;input, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;output, T init=T())</td></tr>
<tr class="memdesc:a523b47ce4da35257c05e7d509e69db2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exclusive scan. <br/></td></tr>
<tr class="separator:a523b47ce4da35257c05e7d509e69db2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b2ded8868f71bc74e4e270d2a8dae9"><td class="memTemplParams" colspan="2">template&lt;class K , class Comp &gt; </td></tr>
<tr class="memitem:a84b2ded8868f71bc74e4e270d2a8dae9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a84b2ded8868f71bc74e4e270d2a8dae9">sort</a> (K &amp;&amp;keys, Comp comp)</td></tr>
<tr class="memdesc:a84b2ded8868f71bc74e4e270d2a8dae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the vector into ascending order.  <a href="#a84b2ded8868f71bc74e4e270d2a8dae9">More...</a><br/></td></tr>
<tr class="separator:a84b2ded8868f71bc74e4e270d2a8dae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bc72755a950140b17b769133e9147a"><td class="memTemplParams" colspan="2"><a class="anchor" id="a60bc72755a950140b17b769133e9147a"></a>
template&lt;class K &gt; </td></tr>
<tr class="memitem:a60bc72755a950140b17b769133e9147a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a60bc72755a950140b17b769133e9147a">sort</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; K &gt; &amp;keys)</td></tr>
<tr class="memdesc:a60bc72755a950140b17b769133e9147a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in keys and values into ascending key order. <br/></td></tr>
<tr class="separator:a60bc72755a950140b17b769133e9147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0d7aa078f1ae079e3a06708d9b84b6"><td class="memTemplParams" colspan="2">template&lt;class K , class V , class Comp &gt; </td></tr>
<tr class="memitem:a6c0d7aa078f1ae079e3a06708d9b84b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a6c0d7aa078f1ae079e3a06708d9b84b6">sort_by_key</a> (K &amp;&amp;keys, V &amp;&amp;vals, Comp comp)</td></tr>
<tr class="memdesc:a6c0d7aa078f1ae079e3a06708d9b84b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in keys and values into ascending key order.  <a href="#a6c0d7aa078f1ae079e3a06708d9b84b6">More...</a><br/></td></tr>
<tr class="separator:a6c0d7aa078f1ae079e3a06708d9b84b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b043fcc5a4892ef36b5b6b8a218f38"><td class="memTemplParams" colspan="2"><a class="anchor" id="a29b043fcc5a4892ef36b5b6b8a218f38"></a>
template&lt;class K , class V &gt; </td></tr>
<tr class="memitem:a29b043fcc5a4892ef36b5b6b8a218f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a29b043fcc5a4892ef36b5b6b8a218f38">sort_by_key</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; K &gt; &amp;keys, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; V &gt; &amp;vals)</td></tr>
<tr class="memdesc:a29b043fcc5a4892ef36b5b6b8a218f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements in keys and values into ascending key order. <br/></td></tr>
<tr class="separator:a29b043fcc5a4892ef36b5b6b8a218f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04547c51b46e0005b37ad00493f7354"><td class="memTemplParams" colspan="2">template&lt;typename val_t , typename col_t , typename idx_t &gt; </td></tr>
<tr class="memitem:aa04547c51b46e0005b37ad00493f7354"><td class="memTemplItemLeft" align="right" valign="top">inline_spmv&lt; <a class="el" href="classvex_1_1SpMat.html">SpMat</a>&lt; val_t, <br class="typebreak"/>
col_t, idx_t &gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; val_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa04547c51b46e0005b37ad00493f7354">make_inline</a> (const additive_operator&lt;<a class="el" href="classvex_1_1SpMat.html">SpMat</a>&lt; val_t, col_t, idx_t &gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; val_t &gt; &gt; &amp;base)</td></tr>
<tr class="memdesc:aa04547c51b46e0005b37ad00493f7354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlines a sparse matrix - vector product.  <a href="#aa04547c51b46e0005b37ad00493f7354">More...</a><br/></td></tr>
<tr class="separator:aa04547c51b46e0005b37ad00493f7354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74a209f956b87b8dc289aad5498a25c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac74a209f956b87b8dc289aad5498a25c">device_spmv_perf</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q)</td></tr>
<tr class="memdesc:ac74a209f956b87b8dc289aad5498a25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights device wrt to additive_operator performance.  <a href="#ac74a209f956b87b8dc289aad5498a25c">More...</a><br/></td></tr>
<tr class="separator:ac74a209f956b87b8dc289aad5498a25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6771b696fd85328302dfc97cfcdb2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab6771b696fd85328302dfc97cfcdb2a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab6771b696fd85328302dfc97cfcdb2a"><td class="memTemplItemLeft" align="right" valign="top">additive_operator&lt;<a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aab6771b696fd85328302dfc97cfcdb2a">operator*</a> (const <a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt; &amp;s, const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:aab6771b696fd85328302dfc97cfcdb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve the stencil with the vector. <br/></td></tr>
<tr class="separator:aab6771b696fd85328302dfc97cfcdb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e2970a3749f0158f51a485907a6576"><td class="memTemplParams" colspan="2"><a class="anchor" id="a43e2970a3749f0158f51a485907a6576"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43e2970a3749f0158f51a485907a6576"><td class="memTemplItemLeft" align="right" valign="top">additive_operator&lt;<a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a43e2970a3749f0158f51a485907a6576">operator*</a> (const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;x, const <a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:a43e2970a3749f0158f51a485907a6576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve the stencil with the vector. <br/></td></tr>
<tr class="separator:a43e2970a3749f0158f51a485907a6576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31259ad9c0db468f3f73e1decf8d0c14"><td class="memTemplParams" colspan="2">template&lt;size_t Tag, class Expr &gt; </td></tr>
<tr class="memitem:a31259ad9c0db468f3f73e1decf8d0c14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a31259ad9c0db468f3f73e1decf8d0c14">tag</a> (const Expr &amp;expr) -&gt; const tagged_terminal&lt; Tag, &gt;</td></tr>
<tr class="memdesc:a31259ad9c0db468f3f73e1decf8d0c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags terminal with a unique (in a single expression) tag.  <a href="#a31259ad9c0db468f3f73e1decf8d0c14">More...</a><br/></td></tr>
<tr class="separator:a31259ad9c0db468f3f73e1decf8d0c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="memTemplParams" colspan="2">template&lt;size_t Tag, typename T , class Expr &gt; </td></tr>
<tr class="memitem:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="memTemplItemLeft" align="right" valign="top">temporary&lt; T, Tag, Expr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae1e84dcac8995e5fbfb0cc2848d94297">make_temp</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create temporary to be reused in a vector expression.  <a href="#ae1e84dcac8995e5fbfb0cc2848d94297">More...</a><br/></td></tr>
<tr class="separator:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad59a3b060765aaee879da333ac3a812"><td class="memTemplParams" colspan="2">template&lt;size_t Tag, class Expr &gt; </td></tr>
<tr class="memitem:aad59a3b060765aaee879da333ac3a812"><td class="memTemplItemLeft" align="right" valign="top">temporary&lt; typename <br class="typebreak"/>
detail::return_type&lt; Expr &gt;<br class="typebreak"/>
::type, Tag, Expr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aad59a3b060765aaee879da333ac3a812">make_temp</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:aad59a3b060765aaee879da333ac3a812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create temporary to be reused in a vector expression.  <a href="#aad59a3b060765aaee879da333ac3a812">More...</a><br/></td></tr>
<tr class="separator:aad59a3b060765aaee879da333ac3a812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c7748602834bd3b8b86762a0970a94"><td class="memTemplParams" colspan="2">template&lt;class Condition , class Message &gt; </td></tr>
<tr class="memitem:a94c7748602834bd3b8b86762a0970a94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a94c7748602834bd3b8b86762a0970a94">precondition</a> (const Condition &amp;condition, const Message &amp;fail_message)</td></tr>
<tr class="memdesc:a94c7748602834bd3b8b86762a0970a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check run-time condition.  <a href="#a94c7748602834bd3b8b86762a0970a94">More...</a><br/></td></tr>
<tr class="separator:a94c7748602834bd3b8b86762a0970a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08607ab86b8756c1bd30c651c6a7ab3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08607ab86b8756c1bd30c651c6a7ab3b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a08607ab86b8756c1bd30c651c6a7ab3b">nextpow2</a> (size_t x)</td></tr>
<tr class="memdesc:a08607ab86b8756c1bd30c651c6a7ab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return next power of 2. <br/></td></tr>
<tr class="separator:a08607ab86b8756c1bd30c651c6a7ab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde6e399118c4e9c8fdb111d23d65698"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adde6e399118c4e9c8fdb111d23d65698"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#adde6e399118c4e9c8fdb111d23d65698">alignup</a> (size_t n, size_t m=16U)</td></tr>
<tr class="memdesc:adde6e399118c4e9c8fdb111d23d65698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align n to the next multiple of m. <br/></td></tr>
<tr class="separator:adde6e399118c4e9c8fdb111d23d65698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec621a57aaa5e1e17619376714b34c6"><td class="memTemplParams" colspan="2"><a class="anchor" id="acec621a57aaa5e1e17619376714b34c6"></a>
template&lt;class T , class... Tail&gt; </td></tr>
<tr class="memitem:acec621a57aaa5e1e17619376714b34c6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 1+sizeof...(Tail)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a> (T t, Tail...tail)</td></tr>
<tr class="memdesc:acec621a57aaa5e1e17619376714b34c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create std::array from arguments. <br/></td></tr>
<tr class="separator:acec621a57aaa5e1e17619376714b34c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3688791c9b5aa7a26c7a63d9684b481c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a3688791c9b5aa7a26c7a63d9684b481c">device_vector_perf</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;)</td></tr>
<tr class="memdesc:a3688791c9b5aa7a26c7a63d9684b481c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights device wrt to vector performance.  <a href="#a3688791c9b5aa7a26c7a63d9684b481c">More...</a><br/></td></tr>
<tr class="separator:a3688791c9b5aa7a26c7a63d9684b481c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629ee8dc1d5241fcfbc0289fbb8e7b0e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a629ee8dc1d5241fcfbc0289fbb8e7b0e">equal_weights</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;)</td></tr>
<tr class="memdesc:a629ee8dc1d5241fcfbc0289fbb8e7b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns equal weight to each device.  <a href="#a629ee8dc1d5241fcfbc0289fbb8e7b0e">More...</a><br/></td></tr>
<tr class="separator:a629ee8dc1d5241fcfbc0289fbb8e7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7740d79c763aba34de005e957fb27db5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a7740d79c763aba34de005e957fb27db5">set_partitioning</a> (std::function&lt; double(const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;) &gt; f)</td></tr>
<tr class="memdesc:a7740d79c763aba34de005e957fb27db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitioning scheme for vectors and matrices.  <a href="#a7740d79c763aba34de005e957fb27db5">More...</a><br/></td></tr>
<tr class="separator:a7740d79c763aba34de005e957fb27db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08b03eaab6548720caf55e47f5cfc91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae08b03eaab6548720caf55e47f5cfc91"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae08b03eaab6548720caf55e47f5cfc91">partition</a> (size_t n, const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:ae08b03eaab6548720caf55e47f5cfc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns partitioning for the specified vector size on a given set of queues. <br/></td></tr>
<tr class="separator:ae08b03eaab6548720caf55e47f5cfc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135f84b29097383ebaeafc866785fdd9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a135f84b29097383ebaeafc866785fdd9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a135f84b29097383ebaeafc866785fdd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a135f84b29097383ebaeafc866785fdd9">copy</a> (const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, std::vector&lt; T &gt; &amp;hv, bool blocking=true)</td></tr>
<tr class="memdesc:a135f84b29097383ebaeafc866785fdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy device vector to host vector. <br/></td></tr>
<tr class="separator:a135f84b29097383ebaeafc866785fdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38ed8c7913492957642ba36137e3dad"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad38ed8c7913492957642ba36137e3dad"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad38ed8c7913492957642ba36137e3dad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ad38ed8c7913492957642ba36137e3dad">copy</a> (const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, T *hv, bool blocking=true)</td></tr>
<tr class="memdesc:ad38ed8c7913492957642ba36137e3dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy device vector to host pointer. <br/></td></tr>
<tr class="separator:ad38ed8c7913492957642ba36137e3dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2cb4d14c4be271957e991da2dc475c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c2cb4d14c4be271957e991da2dc475c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4c2cb4d14c4be271957e991da2dc475c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a4c2cb4d14c4be271957e991da2dc475c">copy</a> (const std::vector&lt; T &gt; &amp;hv, <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, bool blocking=true)</td></tr>
<tr class="memdesc:a4c2cb4d14c4be271957e991da2dc475c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host vector to device vector. <br/></td></tr>
<tr class="separator:a4c2cb4d14c4be271957e991da2dc475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac276f100e959f4afed345409ee2bc50d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac276f100e959f4afed345409ee2bc50d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac276f100e959f4afed345409ee2bc50d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac276f100e959f4afed345409ee2bc50d">copy</a> (const T *hv, <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, bool blocking=true)</td></tr>
<tr class="memdesc:ac276f100e959f4afed345409ee2bc50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host pointer to device vector. <br/></td></tr>
<tr class="separator:ac276f100e959f4afed345409ee2bc50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae178cb03057d2aed93ab059c78631e8b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ae178cb03057d2aed93ab059c78631e8b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae178cb03057d2aed93ab059c78631e8b">copy</a> (InputIterator first, InputIterator last, OutputIterator result, bool blocking=true)</td></tr>
<tr class="memdesc:ae178cb03057d2aed93ab059c78631e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy range from device vector to host vector.  <a href="#ae178cb03057d2aed93ab059c78631e8b">More...</a><br/></td></tr>
<tr class="separator:ae178cb03057d2aed93ab059c78631e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c514253c0f09c5a18dac3e687553465"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c514253c0f09c5a18dac3e687553465"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c514253c0f09c5a18dac3e687553465"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a6c514253c0f09c5a18dac3e687553465">swap</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;x, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a6c514253c0f09c5a18dac3e687553465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two vectors. <br/></td></tr>
<tr class="separator:a6c514253c0f09c5a18dac3e687553465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7718ddf9ae8ee16668a07d874f1e4d82"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a7718ddf9ae8ee16668a07d874f1e4d82">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download and print the vector elements. <br/></td></tr>
<tr class="separator:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca1d21b77d4ea7494aa032c9bb81db8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afca1d21b77d4ea7494aa032c9bb81db8"><td class="memTemplItemLeft" align="right" valign="top">vector_pointer&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#afca1d21b77d4ea7494aa032c9bb81db8">raw_pointer</a> (const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:afca1d21b77d4ea7494aa032c9bb81db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <a class="el" href="classvex_1_1vector.html" title="Device vector. ">vex::vector</a> to a raw pointer.  <a href="#afca1d21b77d4ea7494aa032c9bb81db8">More...</a><br/></td></tr>
<tr class="separator:afca1d21b77d4ea7494aa032c9bb81db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="memTemplParams" colspan="2">template&lt;class Expr &gt; </td></tr>
<tr class="memitem:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="memTemplItemLeft" align="right" valign="top">expr_permutation&lt; Expr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">permutation</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns permutation functor which is based on an integral expression.  <a href="#a1d8048e3bb5185ab018e9d0a0649ef0b">More...</a><br/></td></tr>
<tr class="separator:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fee73e544429d5e986f932a26cb4408"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fee73e544429d5e986f932a26cb4408"></a>
template&lt;class RDC , typename Expr , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:a1fee73e544429d5e986f932a26cb4408"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; Expr, <br class="typebreak"/>
NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1fee73e544429d5e986f932a26cb4408">reduce</a> (const vector_view&lt; Expr, <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &gt; &amp;view, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:a1fee73e544429d5e986f932a26cb4408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vector_view along specified dimensions. <br/></td></tr>
<tr class="separator:a1fee73e544429d5e986f932a26cb4408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ed38cdf2814b4c0a339c59868a52ec4"></a>
template&lt;class RDC , typename Expr , size_t NDIM&gt; </td></tr>
<tr class="memitem:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; Expr, <br class="typebreak"/>
NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a8ed38cdf2814b4c0a339c59868a52ec4">reduce</a> (const vector_view&lt; Expr, <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &gt; &amp;view, size_t reduce_dim)</td></tr>
<tr class="memdesc:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vector_view along specified dimension. <br/></td></tr>
<tr class="separator:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14a59d7fe62f48a61cadd5098f82f80"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab14a59d7fe62f48a61cadd5098f82f80"></a>
template&lt;class RDC , typename Expr , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:ab14a59d7fe62f48a61cadd5098f82f80"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename <br class="typebreak"/>
boost::proto::result_of::as_child<br class="typebreak"/>
&lt; const Expr, vector_domain &gt;<br class="typebreak"/>
::type, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab14a59d7fe62f48a61cadd5098f82f80">reduce</a> (const <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &amp;slice, const Expr &amp;expr, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:ab14a59d7fe62f48a61cadd5098f82f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimensions. <br/></td></tr>
<tr class="separator:ab14a59d7fe62f48a61cadd5098f82f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac77b2a657d4d26f3b8348c9ac1be02f4"></a>
template&lt;class RDC , typename Expr , size_t NDIM&gt; </td></tr>
<tr class="memitem:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename <br class="typebreak"/>
boost::proto::result_of::as_child<br class="typebreak"/>
&lt; const Expr, vector_domain &gt;<br class="typebreak"/>
::type, NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac77b2a657d4d26f3b8348c9ac1be02f4">reduce</a> (const <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &amp;slice, const Expr &amp;expr, size_t reduce_dim)</td></tr>
<tr class="memdesc:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimension. <br/></td></tr>
<tr class="separator:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00792964db2b9c9b2bd784383cd46037"><td class="memTemplParams" colspan="2"><a class="anchor" id="a00792964db2b9c9b2bd784383cd46037"></a>
template&lt;class RDC , typename Expr , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:a00792964db2b9c9b2bd784383cd46037"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename <br class="typebreak"/>
boost::proto::result_of::as_child<br class="typebreak"/>
&lt; const Expr, vector_domain &gt;<br class="typebreak"/>
::type, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a00792964db2b9c9b2bd784383cd46037">reduce</a> (const extent_gen&lt; NDIM &gt; &amp;ext, const Expr &amp;expr, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:a00792964db2b9c9b2bd784383cd46037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimensions. <br/></td></tr>
<tr class="separator:a00792964db2b9c9b2bd784383cd46037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe6c5fb7f45a204216fe8cc5a8077b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="aabe6c5fb7f45a204216fe8cc5a8077b8"></a>
template&lt;class RDC , typename Expr , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:aabe6c5fb7f45a204216fe8cc5a8077b8"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename <br class="typebreak"/>
boost::proto::result_of::as_child<br class="typebreak"/>
&lt; const Expr, vector_domain &gt;<br class="typebreak"/>
::type, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aabe6c5fb7f45a204216fe8cc5a8077b8">reduce</a> (const extent_gen&lt; NDIM &gt; &amp;ext, const Expr &amp;expr, const extent_gen&lt; NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:aabe6c5fb7f45a204216fe8cc5a8077b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimensions. <br/></td></tr>
<tr class="separator:aabe6c5fb7f45a204216fe8cc5a8077b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb11762cd37576f01efe61862c39d032"><td class="memTemplParams" colspan="2"><a class="anchor" id="abb11762cd37576f01efe61862c39d032"></a>
template&lt;class RDC , typename Expr , size_t NDIM&gt; </td></tr>
<tr class="memitem:abb11762cd37576f01efe61862c39d032"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename <br class="typebreak"/>
boost::proto::result_of::as_child<br class="typebreak"/>
&lt; const Expr, vector_domain &gt;<br class="typebreak"/>
::type, NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#abb11762cd37576f01efe61862c39d032">reduce</a> (const extent_gen&lt; NDIM &gt; &amp;ext, const Expr &amp;expr, size_t reduce_dim)</td></tr>
<tr class="memdesc:abb11762cd37576f01efe61862c39d032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimension. <br/></td></tr>
<tr class="separator:abb11762cd37576f01efe61862c39d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159a23f567b28d7d284fa0cd720e900a"><td class="memTemplParams" colspan="2">template&lt;class Expr , size_t Nout, size_t Nin&gt; </td></tr>
<tr class="memitem:a159a23f567b28d7d284fa0cd720e900a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a> (const Expr &amp;expr, const std::array&lt; size_t, Nout &gt; &amp;dst_dims, const std::array&lt; size_t, Nin &gt; &amp;src_dims) -&gt; decltype(<a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(detail::reshape_helper&lt; Nout, Nin &gt;(dst_dims, src_dims)())(expr))</td></tr>
<tr class="memdesc:a159a23f567b28d7d284fa0cd720e900a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes given expression.  <a href="#a159a23f567b28d7d284fa0cd720e900a">More...</a><br/></td></tr>
<tr class="separator:a159a23f567b28d7d284fa0cd720e900a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1cee04e928999c0ce6c069f8d1c901"><td class="memTemplParams" colspan="2">template&lt;class Expr , size_t Nout, size_t Nin&gt; </td></tr>
<tr class="memitem:ade1cee04e928999c0ce6c069f8d1c901"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ade1cee04e928999c0ce6c069f8d1c901">reshape</a> (const Expr &amp;expr, const extent_gen&lt; Nout &gt; &amp;dst_dims, const extent_gen&lt; Nin &gt; &amp;src_dims) -&gt; decltype(<a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(detail::reshape_helper&lt; Nout, Nin &gt;(dst_dims.dim, src_dims.dim)())(expr))</td></tr>
<tr class="memdesc:ade1cee04e928999c0ce6c069f8d1c901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes given expression.  <a href="#ade1cee04e928999c0ce6c069f8d1c901">More...</a><br/></td></tr>
<tr class="separator:ade1cee04e928999c0ce6c069f8d1c901"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac11898b99f6b77ea08316ac19f0e7e86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac11898b99f6b77ea08316ac19f0e7e86"></a>
const <a class="el" href="structvex_1_1range.html">range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac11898b99f6b77ea08316ac19f0e7e86">_</a></td></tr>
<tr class="memdesc:ac11898b99f6b77ea08316ac19f0e7e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for an unbounded range. <br/></td></tr>
<tr class="separator:ac11898b99f6b77ea08316ac19f0e7e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad713fa361047b676e76f2f2d3342dcdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad713fa361047b676e76f2f2d3342dcdd"></a>
const extent_gen&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a></td></tr>
<tr class="memdesc:ad713fa361047b676e76f2f2d3342dcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object for specifying slicer dimensions. <br/></td></tr>
<tr class="separator:ad713fa361047b676e76f2f2d3342dcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c759e462ecb32cf236b5e5379da2f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73c759e462ecb32cf236b5e5379da2f1"></a>
const index_gen&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a73c759e462ecb32cf236b5e5379da2f1">indices</a></td></tr>
<tr class="memdesc:a73c759e462ecb32cf236b5e5379da2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object for specifying slicer shape. <br/></td></tr>
<tr class="separator:a73c759e462ecb32cf236b5e5379da2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Vector expression template library for OpenCL. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae178cb03057d2aed93ab059c78631e8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator vex::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy range from device vector to host vector. </p>
<p>Copy range from host vector to device vector. </p>

</div>
</div>
<a class="anchor" id="ac74a209f956b87b8dc289aad5498a25c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vex::device_spmv_perf </td>
          <td>(</td>
          <td class="paramtype">const backend::command_queue &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weights device wrt to additive_operator performance. </p>
<p>Launches the following kernel on each device: </p>
<div class="fragment"><div class="line">* y = A * x;</div>
<div class="line">* </div>
</div><!-- fragment --><p> where x and y are vectors, and A is matrix for 3D Poisson problem in square domain. Each device gets portion of the vector proportional to the performance of this operation. </p>

<p>References <a class="el" href="classvex_1_1SpMat.html#a8d3b691e6259530d43489215104d9d4a">vex::SpMat&lt; val_t, col_t, idx_t &gt;::apply()</a>, <a class="el" href="classvex_1_1profiler.html#a62711181c6649461f6df957db5f22b0a">vex::profiler&lt; Clock &gt;::tic_cl()</a>, and <a class="el" href="classvex_1_1profiler.html#a0297c22109f3ede4376b33b85a0f3a1c">vex::profiler&lt; Clock &gt;::toc()</a>.</p>

</div>
</div>
<a class="anchor" id="a3688791c9b5aa7a26c7a63d9684b481c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vex::device_vector_perf </td>
          <td>(</td>
          <td class="paramtype">const backend::command_queue &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weights device wrt to vector performance. </p>
<p>Returns device weight after simple bandwidth test.</p>
<p>Launches the following kernel on each device: </p>
<div class="fragment"><div class="line">* a = b + c;</div>
<div class="line">* </div>
</div><!-- fragment --><p> where a, b and c are device vectors. Each device gets portion of the vector proportional to the performance of this operation. </p>

<p>References <a class="el" href="classvex_1_1profiler.html#a62711181c6649461f6df957db5f22b0a">vex::profiler&lt; Clock &gt;::tic_cl()</a>, and <a class="el" href="classvex_1_1profiler.html#a0297c22109f3ede4376b33b85a0f3a1c">vex::profiler&lt; Clock &gt;::toc()</a>.</p>

</div>
</div>
<a class="anchor" id="acf35349b5accc05f96b291457f522acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">elem_index vex::element_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When used in vector expression, returns current element index plus offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Element indices will start from this value. </td></tr>
    <tr><td class="paramname">length</td><td>Specify length of vector expression. This is only relevant when parent expression does not contain any vectors. See monte_carlo_pi test in tests/random.cpp for an example. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a629ee8dc1d5241fcfbc0289fbb8e7b0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vex::equal_weights </td>
          <td>(</td>
          <td class="paramtype">const backend::command_queue &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns equal weight to each device. </p>
<p>This results in equal partitioning. </p>

</div>
</div>
<a class="anchor" id="aa04547c51b46e0005b37ad00493f7354"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename val_t , typename col_t , typename idx_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline_spmv&lt; <a class="el" href="classvex_1_1SpMat.html">SpMat</a>&lt;val_t, col_t, idx_t&gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt;val_t&gt; &gt; vex::make_inline </td>
          <td>(</td>
          <td class="paramtype">const additive_operator&lt;SpMat&lt; val_t, col_t, idx_t &gt;, vector&lt; val_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inlines a sparse matrix - vector product. </p>
<p>When applied to a matrix-vector product, the product becomes inlineable. That is, it may be used in any vector expression (not just additive expression). This is only possible in single-device contexts, so user has to guarantee that.</p>
<p>Example: </p>
<div class="fragment"><div class="line">* <span class="comment">// Get maximum residual value:</span></div>
<div class="line">* eps = sum( fabs(f - <a class="code" href="namespacevex.html#aa04547c51b46e0005b37ad00493f7354">vex::make_inline</a>(A * x)) );</div>
<div class="line">* </div>
</div><!-- fragment --> 
<p>References <a class="el" href="namespacevex.html#a94c7748602834bd3b8b86762a0970a94">precondition()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1e84dcac8995e5fbfb0cc2848d94297"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Tag, typename T , class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">temporary&lt;T, Tag, Expr&gt; ::type vex::make_temp </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create temporary to be reused in a vector expression. </p>
<p>The type of the temporary is explicitly specified. </p>

</div>
</div>
<a class="anchor" id="aad59a3b060765aaee879da333ac3a812"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Tag, class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">temporary&lt;typename detail::return_type&lt;Expr&gt;::type, Tag, Expr&gt; vex::make_temp </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create temporary to be reused in a vector expression. </p>
<p>The type of the temporary is automatically deduced from the supplied expression. </p>

</div>
</div>
<a class="anchor" id="a1d8048e3bb5185ab018e9d0a0649ef0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">expr_permutation&lt;Expr&gt; vex::permutation </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns permutation functor which is based on an integral expression. </p>
<p>Example: </p>
<div class="fragment"><div class="line">* <span class="keyword">auto</span> reverse = <a class="code" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(N - 1 - <a class="code" href="namespacevex.html#acf35349b5accc05f96b291457f522acb">vex::element_index</a>());</div>
<div class="line">* Y = reverse(X);</div>
<div class="line">* </div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="classvex_1_1SpMat.html#a8d3b691e6259530d43489215104d9d4a">vex::SpMat&lt; val_t, col_t, idx_t &gt;::apply()</a>, and <a class="el" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape()</a>.</p>

</div>
</div>
<a class="anchor" id="a94c7748602834bd3b8b86762a0970a94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Condition , class Message &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::precondition </td>
          <td>(</td>
          <td class="paramtype">const Condition &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Message &amp;&#160;</td>
          <td class="paramname"><em>fail_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check run-time condition. </p>
<p>Throws std::runtime_error if condition is false </p>

<p>Referenced by <a class="el" href="classvex_1_1Context.html#ad60f13674fc76037ff47507d4fe58086">vex::Context::Context()</a>, <a class="el" href="namespacevex.html#a4d36c4ddd6b769349ebb2c11badf2199">exclusive_scan()</a>, <a class="el" href="namespacevex.html#a8fc18f46eb80f11430bd7d1fd224e4df">inclusive_scan()</a>, <a class="el" href="namespacevex.html#aa04547c51b46e0005b37ad00493f7354">make_inline()</a>, <a class="el" href="structvex_1_1gslice.html#a5b3aad88352f5da13754544d83cbea82">vex::gslice&lt; NR &gt;::operator()()</a>, <a class="el" href="namespacevex.html#afca1d21b77d4ea7494aa032c9bb81db8">raw_pointer()</a>, and <a class="el" href="classvex_1_1vector.html#a9c2de310d894fca15385030ae906d545">vex::vector&lt; T &gt;::vector()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f3700c5a3fd689cebd1c3301266b7ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::push_compile_options </td>
          <td>(</td>
          <td class="paramtype">const backend::command_queue &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set global compute kernel compilation options for a given device. </p>
<p>This replaces any previously set options. To roll back, call <a class="el" href="namespacevex.html#ac07c402052137a80de67e1137f258341" title="Rolls back changes to compile options. ">pop_compile_options()</a>. </p>

</div>
</div>
<a class="anchor" id="aa16dc38863b68e8c2cd28a117044a3b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::push_program_header </td>
          <td>(</td>
          <td class="paramtype">const backend::command_queue &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set global compute kernel header for a given device. </p>
<p>This replaces any previously set header. To roll back, call <a class="el" href="namespacevex.html#a1f5371f8233d7cfed97b68e3126e860e" title="Rolls back changes to compile options. ">pop_program_header()</a>. </p>

</div>
</div>
<a class="anchor" id="afca1d21b77d4ea7494aa032c9bb81db8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector_pointer&lt;T&gt; vex::raw_pointer </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast <a class="el" href="classvex_1_1vector.html" title="Device vector. ">vex::vector</a> to a raw pointer. </p>
<p>Useful when user wants to get a pointer to a vector instead of its current element inside a vector expression. Could be combined with calls to address_of/dereference operators or with user-defined functions iterating through the vector. See examples in tests/vector_pointer.cpp. </p>

<p>References <a class="el" href="classvex_1_1vector.html#a8877ef727c9a101d5a347f41c0ed6787">vex::vector&lt; T &gt;::nparts()</a>, and <a class="el" href="namespacevex.html#a94c7748602834bd3b8b86762a0970a94">precondition()</a>.</p>

</div>
</div>
<a class="anchor" id="a159a23f567b28d7d284fa0cd720e900a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Expr , size_t Nout, size_t Nin&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vex::reshape </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; size_t, Nout &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; size_t, Nin &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(detail::reshape_helper&lt;Nout, Nin&gt;(dst_dims, src_dims)())(expr))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes given expression. </p>
<p>Makes a multidimensional expression of dst_dims dimensions from input expression shaped as specified by src_dim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Input expression </td></tr>
    <tr><td class="paramname">dst_dims</td><td>dimensions of the resulting expression. </td></tr>
    <tr><td class="paramname">src_dims</td><td>dimensions of the input expressions. Specified as positions in dst_dims.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line">* <span class="comment">// Matrix transposition:</span></div>
<div class="line">* <span class="keyword">auto</span> B = <a class="code" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a>(A, make_array&lt;size_t&gt;(n, m), <a class="code" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a>(1, 0));</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Expand 1D vector to a 2D matrix (by copying along redundant dimension):</span></div>
<div class="line">* <span class="keyword">auto</span> A = <a class="code" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a>(x, <a class="code" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a>(n, m), <a class="code" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a>(0));</div>
<div class="line">* </div>
</div><!-- fragment --> 
<p>References <a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">permutation()</a>.</p>

</div>
</div>
<a class="anchor" id="ade1cee04e928999c0ce6c069f8d1c901"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Expr , size_t Nout, size_t Nin&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vex::reshape </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const extent_gen&lt; Nout &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const extent_gen&lt; Nin &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(detail::reshape_helper&lt;Nout, Nin&gt;(dst_dims.dim, src_dims.dim)())(expr))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes given expression. </p>
<p>Makes a multidimensional expression of dst_dims dimensions from input expression shaped as specified by src_dim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Input expression </td></tr>
    <tr><td class="paramname">dst_dims</td><td>dimensions of the resulting expression. </td></tr>
    <tr><td class="paramname">src_dims</td><td>dimensions of the input expressions. Specified as positions in dst_dims.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line">* <span class="comment">// Matrix transposition:</span></div>
<div class="line">* <span class="keyword">auto</span> B = <a class="code" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a>(A, <a class="code" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a>[n][m], <a class="code" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a>[1][0]);</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Expand 1D vector to a 2D matrix (by copying along redundant dimension):</span></div>
<div class="line">* <span class="keyword">auto</span> A = <a class="code" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a>(x, <a class="code" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a>[n][m], <a class="code" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a>[0]);</div>
<div class="line">* </div>
</div><!-- fragment --> 
<p>References <a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">permutation()</a>.</p>

</div>
</div>
<a class="anchor" id="a7740d79c763aba34de005e957fb27db5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::set_partitioning </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(const backend::command_queue &amp;) &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partitioning scheme for vectors and matrices. </p>
<p>Should be set once before any object of vector or matrix type is declared. Otherwise default parttioning function (partition_by_vector_perf) is selected. </p>

</div>
</div>
<a class="anchor" id="a0ee2afe5ab14567e3900ecea19e46c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vex::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort. </p>
<p>If there are more than one device in vector's queue list, then all partitions are sorted individually on GPUs and then merged on CPU. </p>

<p>References <a class="el" href="namespacevex.html#aaa68b032f0d66695e3b3b6c5375e8cf6">copy()</a>, <a class="el" href="classvex_1_1vector.html#a6084024536baf2bc26d75e3734283818">vex::vector&lt; T &gt;::part_size()</a>, <a class="el" href="classvex_1_1vector.html#a52c7bf21a4d87c503bf6debfec8e2f1a">vex::vector&lt; T &gt;::part_start()</a>, <a class="el" href="classvex_1_1vector.html#ae6b48f08d3b85d3e6334425f9fa51ffd">vex::vector&lt; T &gt;::queue_list()</a>, and <a class="el" href="classvex_1_1vector.html#acba96d67dcc97afdc6ff552d913ca7d7">vex::vector&lt; T &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="namespacevex.html#a60bc72755a950140b17b769133e9147a">sort()</a>.</p>

</div>
</div>
<a class="anchor" id="a84b2ded8868f71bc74e4e270d2a8dae9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vex::sort </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the vector into ascending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>comparison function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6c0d7aa078f1ae079e3a06708d9b84b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , class Comp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vex::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">K &amp;&amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">V &amp;&amp;&#160;</td>
          <td class="paramname"><em>vals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comp&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the elements in keys and values into ascending key order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td>comparison function. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="namespacevex.html#a29b043fcc5a4892ef36b5b6b8a218f38">sort_by_key()</a>.</p>

</div>
</div>
<a class="anchor" id="a31259ad9c0db468f3f73e1decf8d0c14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Tag, class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vex::tag </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> -&gt; const tagged_terminal&lt;
                        Tag,

                &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tags terminal with a unique (in a single expression) tag. </p>
<p>By tagging terminals user guarantees that the terminals with same tags actually refer to the same data. VexCL is able to use this information in order to reduce number of kernel parameters and unnecessary global memory I/O operations.</p>
<p>Example: </p>
<div class="fragment"><div class="line">* s = sum(tag&lt;1&gt;(x) * tag&lt;1&gt;(x) + tag&lt;2&gt;(y) * tag&lt;2&gt;(y));</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab7ed95396644bcef1aff9a0cac89e69a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Expr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">expression_tuple&lt; std::tuple&lt;const Expr&amp;...&gt; &gt; vex::tie </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;...&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ties several vector expressions into writeable tuple. </p>
<p>The following example results in a single kernel: </p>
<div class="fragment"><div class="line">* <a class="code" href="classvex_1_1vector.html">vex::vector&lt;double&gt;</a> x(ctx, 1024);</div>
<div class="line">* <a class="code" href="classvex_1_1vector.html">vex::vector&lt;double&gt;</a> y(ctx, 1024);</div>
<div class="line">*</div>
<div class="line">* <a class="code" href="namespacevex.html#ab7ed95396644bcef1aff9a0cac89e69a">vex::tie</a>(x,y) = <a class="code" href="namespacevex.html#ab7ed95396644bcef1aff9a0cac89e69a">std::tie</a>( x + y, y - x );</div>
<div class="line">* </div>
</div><!-- fragment --><p> This is functionally equivalent to </p>
<div class="fragment"><div class="line">* tmp_x = x + y;</div>
<div class="line">* tmp_y = y - x;</div>
<div class="line">* x = tmp_x;</div>
<div class="line">* y = tmp_y;</div>
<div class="line">* </div>
</div><!-- fragment --><p> but does not use temporaries and is more efficient. </p>

<p>Referenced by <a class="el" href="namespacevex_1_1generator.html#a4c60e9f68a2e74de54a073730704532e">vex::generator::build_kernel()</a>, <a class="el" href="classvex_1_1Context.html#ad60f13674fc76037ff47507d4fe58086">vex::Context::Context()</a>, <a class="el" href="namespacevex_1_1generator.html#af0263b233e113206855f28eb745b7ec8">vex::generator::make_function()</a>, <a class="el" href="classvex_1_1mba.html#a5660107fe6178eec3173b39288583494">vex::mba&lt; NDIM, real &gt;::operator()()</a>, and <a class="el" href="classvex_1_1generator_1_1Kernel.html#aff818a250c0ad905cc9cd9c98cfa427e">vex::generator::Kernel&lt; NP &gt;::operator()()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
