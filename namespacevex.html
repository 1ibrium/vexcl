<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>VexCL: vex Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VexCL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vex Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Vector expression template library for OpenCL.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevex_1_1backend"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1backend.html">backend</a></td></tr>
<tr class="memdesc:namespacevex_1_1backend"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend-specific functionality. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1constants"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1constants.html">constants</a></td></tr>
<tr class="memdesc:namespacevex_1_1constants"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mathematical constants. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1fft"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1fft.html">fft</a></td></tr>
<tr class="memdesc:namespacevex_1_1fft"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier Transform. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1Filter"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1Filter.html">Filter</a></td></tr>
<tr class="memdesc:namespacevex_1_1Filter"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device filters. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1generator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1generator.html">generator</a></td></tr>
<tr class="memdesc:namespacevex_1_1generator"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvex_1_1generator_1_1Kernel.html" title="Autogenerated kernel. ">Kernel</a> generation interface. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevex_1_1random"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex_1_1random.html">random</a></td></tr>
<tr class="memdesc:namespacevex_1_1random"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvex_1_1Random.html" title="A random generator. ">Random</a> generators. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A random generator.  <a href="structvex_1_1Random.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1RandomNormal.html">RandomNormal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns normal distributed random numbers.  <a href="structvex_1_1RandomNormal.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1FFT.html">FFT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast Fourier Transform.  <a href="structvex_1_1FFT.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1mba.html">mba</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scattered data interpolation with multilevel B-Splines.  <a href="classvex_1_1mba.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1multivector.html">multivector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for several vex::vectors.  <a href="classvex_1_1multivector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1stopwatch.html">stopwatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A stopwatch that computes the median and mean of individual timings.  <a href="classvex_1_1stopwatch.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1profiler.html">profiler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for gathering and printing OpenCL and Host profiling info.  <a href="classvex_1_1profiler.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1SUM.html">SUM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summation. Should be used as a template parameter for <a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression. ">Reductor</a> class.  <a href="structvex_1_1SUM.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1MAX.html">MAX</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum element. Should be used as a template parameter for <a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression. ">Reductor</a> class.  <a href="structvex_1_1MAX.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1MIN.html">MIN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum element. Should be used as a template parameter for <a class="el" href="classvex_1_1Reductor.html" title="Parallel reduction of arbitrary expression. ">Reductor</a> class.  <a href="structvex_1_1MIN.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1Reductor.html">Reductor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel reduction of arbitrary expression.  <a href="classvex_1_1Reductor.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1SpMatCCSR.html">SpMatCCSR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix in CCSR format.  <a href="structvex_1_1SpMatCCSR.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1SpMat.html">SpMat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sparse matrix in hybrid ELL-CSR format.  <a href="classvex_1_1SpMat.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1stencil.html">stencil</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stencil.  <a href="classvex_1_1stencil.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1StencilOperator.html">StencilOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">User-defined stencil operator.  <a href="classvex_1_1StencilOperator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvex_1_1vector.html">vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device vector.  <a href="classvex_1_1vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1gslice.html">gslice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generalized slice selector.  <a href="structvex_1_1gslice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1range.html">range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An index range for use with slicer class.  <a href="structvex_1_1range.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvex_1_1slicer.html">slicer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slicing operator.  <a href="structvex_1_1slicer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2f3700c5a3fd689cebd1c3301266b7ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a2f3700c5a3fd689cebd1c3301266b7ff">push_compile_options</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q, const std::string &amp;str)</td></tr>
<tr class="memdesc:a2f3700c5a3fd689cebd1c3301266b7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global compute kernel compilation options for a given device.  <a href="#a2f3700c5a3fd689cebd1c3301266b7ff">More...</a><br/></td></tr>
<tr class="separator:a2f3700c5a3fd689cebd1c3301266b7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07c402052137a80de67e1137f258341"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac07c402052137a80de67e1137f258341"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac07c402052137a80de67e1137f258341">pop_compile_options</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q)</td></tr>
<tr class="memdesc:ac07c402052137a80de67e1137f258341"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options. <br/></td></tr>
<tr class="separator:ac07c402052137a80de67e1137f258341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16dc38863b68e8c2cd28a117044a3b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa16dc38863b68e8c2cd28a117044a3b6">push_program_header</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q, const std::string &amp;str)</td></tr>
<tr class="memdesc:aa16dc38863b68e8c2cd28a117044a3b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global compute kernel header for a given device.  <a href="#aa16dc38863b68e8c2cd28a117044a3b6">More...</a><br/></td></tr>
<tr class="separator:aa16dc38863b68e8c2cd28a117044a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f5371f8233d7cfed97b68e3126e860e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f5371f8233d7cfed97b68e3126e860e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1f5371f8233d7cfed97b68e3126e860e">pop_program_header</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q)</td></tr>
<tr class="memdesc:a1f5371f8233d7cfed97b68e3126e860e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options. <br/></td></tr>
<tr class="separator:a1f5371f8233d7cfed97b68e3126e860e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9db4bda4971c23090ce43eb9e578f65"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9db4bda4971c23090ce43eb9e578f65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab9db4bda4971c23090ce43eb9e578f65">push_compile_options</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue, const std::string &amp;str)</td></tr>
<tr class="memdesc:ab9db4bda4971c23090ce43eb9e578f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global compute kernel compilation options for each device in queue list. <br/></td></tr>
<tr class="separator:ab9db4bda4971c23090ce43eb9e578f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87387b148e5f12d36cea89fdfb7a11cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a87387b148e5f12d36cea89fdfb7a11cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a87387b148e5f12d36cea89fdfb7a11cd">pop_compile_options</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:a87387b148e5f12d36cea89fdfb7a11cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options for each device in queue list. <br/></td></tr>
<tr class="separator:a87387b148e5f12d36cea89fdfb7a11cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a560d2aca37d3493b5cdd4bd317e72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00a560d2aca37d3493b5cdd4bd317e72"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a00a560d2aca37d3493b5cdd4bd317e72">push_program_header</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue, const std::string &amp;str)</td></tr>
<tr class="memdesc:a00a560d2aca37d3493b5cdd4bd317e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set global OpenCL program header for each device in queue list. <br/></td></tr>
<tr class="separator:a00a560d2aca37d3493b5cdd4bd317e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d16252288166999a5494d04f35cf9c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6d16252288166999a5494d04f35cf9c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae6d16252288166999a5494d04f35cf9c">pop_program_header</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:ae6d16252288166999a5494d04f35cf9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rolls back changes to compile options for each device in queue list. <br/></td></tr>
<tr class="separator:ae6d16252288166999a5494d04f35cf9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8327486578e0ab169174a502b8a7fe4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8327486578e0ab169174a502b8a7fe4"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa8327486578e0ab169174a502b8a7fe4">path_delim</a> ()</td></tr>
<tr class="memdesc:aa8327486578e0ab169174a502b8a7fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path delimiter symbol. <br/></td></tr>
<tr class="separator:aa8327486578e0ab169174a502b8a7fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5ead15e3e07a03b02228d137548be7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f5ead15e3e07a03b02228d137548be7"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a0f5ead15e3e07a03b02228d137548be7">appdata_path</a> ()</td></tr>
<tr class="memdesc:a0f5ead15e3e07a03b02228d137548be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to appdata folder. <br/></td></tr>
<tr class="separator:a0f5ead15e3e07a03b02228d137548be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad813c378c0e17666ad73c9dd3ab504"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ad813c378c0e17666ad73c9dd3ab504"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1ad813c378c0e17666ad73c9dd3ab504">program_binaries_path</a> (const std::string &amp;hash, bool create=false)</td></tr>
<tr class="memdesc:a1ad813c378c0e17666ad73c9dd3ab504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Path to cached binaries. <br/></td></tr>
<tr class="separator:a1ad813c378c0e17666ad73c9dd3ab504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dac744b63fbd08c03814bb6ab6ee81c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8dac744b63fbd08c03814bb6ab6ee81c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a8dac744b63fbd08c03814bb6ab6ee81c">sha1</a> (const std::string &amp;src)</td></tr>
<tr class="memdesc:a8dac744b63fbd08c03814bb6ab6ee81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns SHA1 hash of the string parameter. <br/></td></tr>
<tr class="separator:a8dac744b63fbd08c03814bb6ab6ee81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9257e12cbac42bcd8cb21973b63cba"><td class="memTemplParams" colspan="2"><a class="anchor" id="aec9257e12cbac42bcd8cb21973b63cba"></a>
template&lt;typename T , class Expr &gt; </td></tr>
<tr class="memitem:aec9257e12cbac42bcd8cb21973b63cba"><td class="memTemplItemLeft" align="right" valign="top">casted_expession&lt; T, Expr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aec9257e12cbac42bcd8cb21973b63cba">cast</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:aec9257e12cbac42bcd8cb21973b63cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast an expression to a given type. <br/></td></tr>
<tr class="separator:aec9257e12cbac42bcd8cb21973b63cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf35349b5accc05f96b291457f522acb"><td class="memItemLeft" align="right" valign="top">elem_index&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#acf35349b5accc05f96b291457f522acb">element_index</a> (size_t offset=0, size_t length=0)</td></tr>
<tr class="memdesc:acf35349b5accc05f96b291457f522acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">When used in vector expression, returns current element index plus offset.  <a href="#acf35349b5accc05f96b291457f522acb">More...</a><br/></td></tr>
<tr class="separator:acf35349b5accc05f96b291457f522acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017d6f5c75fa02d04dc5e4eef993978d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a017d6f5c75fa02d04dc5e4eef993978d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a017d6f5c75fa02d04dc5e4eef993978d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a017d6f5c75fa02d04dc5e4eef993978d">inclusive_scan</a> (const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;src, <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dst)</td></tr>
<tr class="memdesc:a017d6f5c75fa02d04dc5e4eef993978d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inclusive scan. <br/></td></tr>
<tr class="separator:a017d6f5c75fa02d04dc5e4eef993978d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee2afe5ab14567e3900ecea19e46c78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0ee2afe5ab14567e3900ecea19e46c78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a0ee2afe5ab14567e3900ecea19e46c78">sort</a> (<a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a0ee2afe5ab14567e3900ecea19e46c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort.  <a href="#a0ee2afe5ab14567e3900ecea19e46c78">More...</a><br/></td></tr>
<tr class="separator:a0ee2afe5ab14567e3900ecea19e46c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a309be2ac9197a3a1f16c3f58da32e4a5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a309be2ac9197a3a1f16c3f58da32e4a5">operator&lt;&lt;</a> (std::ostream &amp;os, const symbolic&lt; T &gt; &amp;sym)</td></tr>
<tr class="memdesc:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends name of the symbolic variable to output stream. <br/></td></tr>
<tr class="separator:a309be2ac9197a3a1f16c3f58da32e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f2a40c6b7a0f4b540ba12f2b52532b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab9f2a40c6b7a0f4b540ba12f2b52532b"></a>
template&lt;class RDC , typename T , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:ab9f2a40c6b7a0f4b540ba12f2b52532b"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt;<br class="typebreak"/>
, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab9f2a40c6b7a0f4b540ba12f2b52532b">reduce</a> (const multi_array&lt; T, NDIM &gt; &amp;m, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:ab9f2a40c6b7a0f4b540ba12f2b52532b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vex::multi_array along the specified dimensions. <br/></td></tr>
<tr class="separator:ab9f2a40c6b7a0f4b540ba12f2b52532b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af475f0b6dadddfa0df505b5be6555fe6"><td class="memTemplParams" colspan="2"><a class="anchor" id="af475f0b6dadddfa0df505b5be6555fe6"></a>
template&lt;class RDC , typename T , size_t NDIM&gt; </td></tr>
<tr class="memitem:af475f0b6dadddfa0df505b5be6555fe6"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt;<br class="typebreak"/>
, NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#af475f0b6dadddfa0df505b5be6555fe6">reduce</a> (const multi_array&lt; T, NDIM &gt; &amp;m, size_t reduce_dim)</td></tr>
<tr class="memdesc:af475f0b6dadddfa0df505b5be6555fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vex::multi_array along the specified dimension. <br/></td></tr>
<tr class="separator:af475f0b6dadddfa0df505b5be6555fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="memTemplParams" colspan="2"><a class="anchor" id="aaa68b032f0d66695e3b3b6c5375e8cf6"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aaa68b032f0d66695e3b3b6c5375e8cf6">copy</a> (const <a class="el" href="classvex_1_1multivector.html">multivector</a>&lt; T, N &gt; &amp;mv, std::vector&lt; T &gt; &amp;hv)</td></tr>
<tr class="memdesc:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy multivector to host vector. <br/></td></tr>
<tr class="separator:aaa68b032f0d66695e3b3b6c5375e8cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11afb8e8e5387abf04e3b7f815111e0e"><td class="memTemplParams" colspan="2"><a class="anchor" id="a11afb8e8e5387abf04e3b7f815111e0e"></a>
template&lt;class T , size_t N&gt; </td></tr>
<tr class="memitem:a11afb8e8e5387abf04e3b7f815111e0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a11afb8e8e5387abf04e3b7f815111e0e">copy</a> (const std::vector&lt; T &gt; &amp;hv, <a class="el" href="classvex_1_1multivector.html">multivector</a>&lt; T, N &gt; &amp;mv)</td></tr>
<tr class="memdesc:a11afb8e8e5387abf04e3b7f815111e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host vector to multivector. <br/></td></tr>
<tr class="separator:a11afb8e8e5387abf04e3b7f815111e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ed95396644bcef1aff9a0cac89e69a"><td class="memTemplParams" colspan="2">template&lt;class... Expr&gt; </td></tr>
<tr class="memitem:ab7ed95396644bcef1aff9a0cac89e69a"><td class="memTemplItemLeft" align="right" valign="top">expression_tuple&lt; std::tuple<br class="typebreak"/>
&lt; const Expr &amp;...&gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab7ed95396644bcef1aff9a0cac89e69a">tie</a> (const Expr &amp;...expr)</td></tr>
<tr class="memdesc:ab7ed95396644bcef1aff9a0cac89e69a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ties several vector expressions into writeable tuple.  <a href="#ab7ed95396644bcef1aff9a0cac89e69a">More...</a><br/></td></tr>
<tr class="separator:ab7ed95396644bcef1aff9a0cac89e69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ec79ec8d6883b9541de849f531772"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b8ec79ec8d6883b9541de849f531772"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a5b8ec79ec8d6883b9541de849f531772">purge_kernel_caches</a> ()</td></tr>
<tr class="memdesc:a5b8ec79ec8d6883b9541de849f531772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached OpenCL kernels, allowing to release OpenCL contexts. <br/></td></tr>
<tr class="separator:a5b8ec79ec8d6883b9541de849f531772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563d351840b2719958e17a653d7ad922"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a563d351840b2719958e17a653d7ad922"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a563d351840b2719958e17a653d7ad922">purge_kernel_caches</a> (backend::kernel_cache_key key)</td></tr>
<tr class="memdesc:a563d351840b2719958e17a653d7ad922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached OpenCL kernels, allowing to release OpenCL contexts. <br/></td></tr>
<tr class="separator:a563d351840b2719958e17a653d7ad922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1670e7948b19b0c6fbcedc816ee70632"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1670e7948b19b0c6fbcedc816ee70632"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1670e7948b19b0c6fbcedc816ee70632">purge_kernel_caches</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:a1670e7948b19b0c6fbcedc816ee70632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears cached OpenCL kernels, allowing to release OpenCL contexts. <br/></td></tr>
<tr class="separator:a1670e7948b19b0c6fbcedc816ee70632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8f8c0901de2d0e5e99605d10b30fb6"><td class="memTemplParams" colspan="2"><a class="anchor" id="abe8f8c0901de2d0e5e99605d10b30fb6"></a>
template&lt;typename T , class R &gt; </td></tr>
<tr class="memitem:abe8f8c0901de2d0e5e99605d10b30fb6"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classvex_1_1Reductor.html">vex::Reductor</a>&lt; T, R &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#abe8f8c0901de2d0e5e99605d10b30fb6">get_reductor</a> (const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:abe8f8c0901de2d0e5e99605d10b30fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a static instance of vex::Reductor&lt;T,R&gt; <br/></td></tr>
<tr class="separator:abe8f8c0901de2d0e5e99605d10b30fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04547c51b46e0005b37ad00493f7354"><td class="memTemplParams" colspan="2">template&lt;typename val_t , typename col_t , typename idx_t &gt; </td></tr>
<tr class="memitem:aa04547c51b46e0005b37ad00493f7354"><td class="memTemplItemLeft" align="right" valign="top">inline_spmv&lt; <a class="el" href="classvex_1_1SpMat.html">SpMat</a>&lt; val_t, <br class="typebreak"/>
col_t, idx_t &gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; val_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aa04547c51b46e0005b37ad00493f7354">make_inline</a> (const additive_operator&lt;<a class="el" href="classvex_1_1SpMat.html">SpMat</a>&lt; val_t, col_t, idx_t &gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; val_t &gt; &gt; &amp;base)</td></tr>
<tr class="memdesc:aa04547c51b46e0005b37ad00493f7354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inlines a sparse matrix - vector product.  <a href="#aa04547c51b46e0005b37ad00493f7354">More...</a><br/></td></tr>
<tr class="separator:aa04547c51b46e0005b37ad00493f7354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74a209f956b87b8dc289aad5498a25c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac74a209f956b87b8dc289aad5498a25c">device_spmv_perf</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;q)</td></tr>
<tr class="memdesc:ac74a209f956b87b8dc289aad5498a25c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights device wrt to additive_operator performance.  <a href="#ac74a209f956b87b8dc289aad5498a25c">More...</a><br/></td></tr>
<tr class="separator:ac74a209f956b87b8dc289aad5498a25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6771b696fd85328302dfc97cfcdb2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aab6771b696fd85328302dfc97cfcdb2a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab6771b696fd85328302dfc97cfcdb2a"><td class="memTemplItemLeft" align="right" valign="top">additive_operator&lt;<a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aab6771b696fd85328302dfc97cfcdb2a">operator*</a> (const <a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt; &amp;s, const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:aab6771b696fd85328302dfc97cfcdb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve the stencil with the vector. <br/></td></tr>
<tr class="separator:aab6771b696fd85328302dfc97cfcdb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e2970a3749f0158f51a485907a6576"><td class="memTemplParams" colspan="2"><a class="anchor" id="a43e2970a3749f0158f51a485907a6576"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43e2970a3749f0158f51a485907a6576"><td class="memTemplItemLeft" align="right" valign="top">additive_operator&lt;<a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt;<br class="typebreak"/>
, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a43e2970a3749f0158f51a485907a6576">operator*</a> (const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;x, const <a class="el" href="classvex_1_1stencil.html">stencil</a>&lt; T &gt; &amp;s)</td></tr>
<tr class="memdesc:a43e2970a3749f0158f51a485907a6576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convolve the stencil with the vector. <br/></td></tr>
<tr class="separator:a43e2970a3749f0158f51a485907a6576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31259ad9c0db468f3f73e1decf8d0c14"><td class="memTemplParams" colspan="2">template&lt;size_t Tag, class Expr &gt; </td></tr>
<tr class="memitem:a31259ad9c0db468f3f73e1decf8d0c14"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a31259ad9c0db468f3f73e1decf8d0c14">tag</a> (const Expr &amp;expr) -&gt; const tagged_terminal&lt; Tag, &gt;</td></tr>
<tr class="memdesc:a31259ad9c0db468f3f73e1decf8d0c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tags terminal with a unique (in a single expression) tag.  <a href="#a31259ad9c0db468f3f73e1decf8d0c14">More...</a><br/></td></tr>
<tr class="separator:a31259ad9c0db468f3f73e1decf8d0c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="memTemplParams" colspan="2">template&lt;size_t Tag, typename T , class Expr &gt; </td></tr>
<tr class="memitem:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="memTemplItemLeft" align="right" valign="top">temporary&lt; T, Tag, Expr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae1e84dcac8995e5fbfb0cc2848d94297">make_temp</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create temporary to be reused in a vector expression.  <a href="#ae1e84dcac8995e5fbfb0cc2848d94297">More...</a><br/></td></tr>
<tr class="separator:ae1e84dcac8995e5fbfb0cc2848d94297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad59a3b060765aaee879da333ac3a812"><td class="memTemplParams" colspan="2">template&lt;size_t Tag, class Expr &gt; </td></tr>
<tr class="memitem:aad59a3b060765aaee879da333ac3a812"><td class="memTemplItemLeft" align="right" valign="top">temporary&lt; typename <br class="typebreak"/>
detail::return_type&lt; Expr &gt;<br class="typebreak"/>
::type, Tag, Expr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#aad59a3b060765aaee879da333ac3a812">make_temp</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:aad59a3b060765aaee879da333ac3a812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create temporary to be reused in a vector expression.  <a href="#aad59a3b060765aaee879da333ac3a812">More...</a><br/></td></tr>
<tr class="separator:aad59a3b060765aaee879da333ac3a812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c7748602834bd3b8b86762a0970a94"><td class="memTemplParams" colspan="2">template&lt;class Condition , class Message &gt; </td></tr>
<tr class="memitem:a94c7748602834bd3b8b86762a0970a94"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a94c7748602834bd3b8b86762a0970a94">precondition</a> (const Condition &amp;condition, const Message &amp;fail_message)</td></tr>
<tr class="memdesc:a94c7748602834bd3b8b86762a0970a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check run-time condition.  <a href="#a94c7748602834bd3b8b86762a0970a94">More...</a><br/></td></tr>
<tr class="separator:a94c7748602834bd3b8b86762a0970a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08607ab86b8756c1bd30c651c6a7ab3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a08607ab86b8756c1bd30c651c6a7ab3b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a08607ab86b8756c1bd30c651c6a7ab3b">nextpow2</a> (size_t x)</td></tr>
<tr class="memdesc:a08607ab86b8756c1bd30c651c6a7ab3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return next power of 2. <br/></td></tr>
<tr class="separator:a08607ab86b8756c1bd30c651c6a7ab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde6e399118c4e9c8fdb111d23d65698"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adde6e399118c4e9c8fdb111d23d65698"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#adde6e399118c4e9c8fdb111d23d65698">alignup</a> (size_t n, size_t m=16U)</td></tr>
<tr class="memdesc:adde6e399118c4e9c8fdb111d23d65698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Align n to the next multiple of m. <br/></td></tr>
<tr class="separator:adde6e399118c4e9c8fdb111d23d65698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec621a57aaa5e1e17619376714b34c6"><td class="memTemplParams" colspan="2"><a class="anchor" id="acec621a57aaa5e1e17619376714b34c6"></a>
template&lt;class T , class... Tail&gt; </td></tr>
<tr class="memitem:acec621a57aaa5e1e17619376714b34c6"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, 1+sizeof...(Tail)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a> (T t, Tail...tail)</td></tr>
<tr class="memdesc:acec621a57aaa5e1e17619376714b34c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create std::array from arguments. <br/></td></tr>
<tr class="separator:acec621a57aaa5e1e17619376714b34c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3688791c9b5aa7a26c7a63d9684b481c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a3688791c9b5aa7a26c7a63d9684b481c">device_vector_perf</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;)</td></tr>
<tr class="memdesc:a3688791c9b5aa7a26c7a63d9684b481c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weights device wrt to vector performance.  <a href="#a3688791c9b5aa7a26c7a63d9684b481c">More...</a><br/></td></tr>
<tr class="separator:a3688791c9b5aa7a26c7a63d9684b481c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629ee8dc1d5241fcfbc0289fbb8e7b0e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a629ee8dc1d5241fcfbc0289fbb8e7b0e">equal_weights</a> (const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;)</td></tr>
<tr class="memdesc:a629ee8dc1d5241fcfbc0289fbb8e7b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns equal weight to each device.  <a href="#a629ee8dc1d5241fcfbc0289fbb8e7b0e">More...</a><br/></td></tr>
<tr class="separator:a629ee8dc1d5241fcfbc0289fbb8e7b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7740d79c763aba34de005e957fb27db5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a7740d79c763aba34de005e957fb27db5">set_partitioning</a> (std::function&lt; double(const <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &amp;) &gt; f)</td></tr>
<tr class="memdesc:a7740d79c763aba34de005e957fb27db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partitioning scheme for vectors and matrices.  <a href="#a7740d79c763aba34de005e957fb27db5">More...</a><br/></td></tr>
<tr class="separator:a7740d79c763aba34de005e957fb27db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08b03eaab6548720caf55e47f5cfc91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae08b03eaab6548720caf55e47f5cfc91"></a>
std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae08b03eaab6548720caf55e47f5cfc91">partition</a> (size_t n, const std::vector&lt; <a class="el" href="classvex_1_1backend_1_1cuda_1_1command__queue.html">backend::command_queue</a> &gt; &amp;queue)</td></tr>
<tr class="memdesc:ae08b03eaab6548720caf55e47f5cfc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns partitioning for the specified vector size on a given set of queues. <br/></td></tr>
<tr class="separator:ae08b03eaab6548720caf55e47f5cfc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135f84b29097383ebaeafc866785fdd9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a135f84b29097383ebaeafc866785fdd9"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a135f84b29097383ebaeafc866785fdd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a135f84b29097383ebaeafc866785fdd9">copy</a> (const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, std::vector&lt; T &gt; &amp;hv, bool blocking=true)</td></tr>
<tr class="memdesc:a135f84b29097383ebaeafc866785fdd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy device vector to host vector. <br/></td></tr>
<tr class="separator:a135f84b29097383ebaeafc866785fdd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38ed8c7913492957642ba36137e3dad"><td class="memTemplParams" colspan="2"><a class="anchor" id="ad38ed8c7913492957642ba36137e3dad"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ad38ed8c7913492957642ba36137e3dad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ad38ed8c7913492957642ba36137e3dad">copy</a> (const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, T *hv, bool blocking=true)</td></tr>
<tr class="memdesc:ad38ed8c7913492957642ba36137e3dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy device vector to host pointer. <br/></td></tr>
<tr class="separator:ad38ed8c7913492957642ba36137e3dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2cb4d14c4be271957e991da2dc475c"><td class="memTemplParams" colspan="2"><a class="anchor" id="a4c2cb4d14c4be271957e991da2dc475c"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a4c2cb4d14c4be271957e991da2dc475c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a4c2cb4d14c4be271957e991da2dc475c">copy</a> (const std::vector&lt; T &gt; &amp;hv, <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, bool blocking=true)</td></tr>
<tr class="memdesc:a4c2cb4d14c4be271957e991da2dc475c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host vector to device vector. <br/></td></tr>
<tr class="separator:a4c2cb4d14c4be271957e991da2dc475c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac276f100e959f4afed345409ee2bc50d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac276f100e959f4afed345409ee2bc50d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ac276f100e959f4afed345409ee2bc50d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac276f100e959f4afed345409ee2bc50d">copy</a> (const T *hv, <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;dv, bool blocking=true)</td></tr>
<tr class="memdesc:ac276f100e959f4afed345409ee2bc50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy host pointer to device vector. <br/></td></tr>
<tr class="separator:ac276f100e959f4afed345409ee2bc50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae178cb03057d2aed93ab059c78631e8b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:ae178cb03057d2aed93ab059c78631e8b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ae178cb03057d2aed93ab059c78631e8b">copy</a> (InputIterator first, InputIterator last, OutputIterator result, bool blocking=true)</td></tr>
<tr class="memdesc:ae178cb03057d2aed93ab059c78631e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy range from device vector to host vector.  <a href="#ae178cb03057d2aed93ab059c78631e8b">More...</a><br/></td></tr>
<tr class="separator:ae178cb03057d2aed93ab059c78631e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c514253c0f09c5a18dac3e687553465"><td class="memTemplParams" colspan="2"><a class="anchor" id="a6c514253c0f09c5a18dac3e687553465"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c514253c0f09c5a18dac3e687553465"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a6c514253c0f09c5a18dac3e687553465">swap</a> (<a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;x, <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a6c514253c0f09c5a18dac3e687553465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two vectors. <br/></td></tr>
<tr class="separator:a6c514253c0f09c5a18dac3e687553465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7718ddf9ae8ee16668a07d874f1e4d82"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a7718ddf9ae8ee16668a07d874f1e4d82">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Download and print the vector elements. <br/></td></tr>
<tr class="separator:a7718ddf9ae8ee16668a07d874f1e4d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca1d21b77d4ea7494aa032c9bb81db8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afca1d21b77d4ea7494aa032c9bb81db8"><td class="memTemplItemLeft" align="right" valign="top">vector_pointer&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#afca1d21b77d4ea7494aa032c9bb81db8">raw_pointer</a> (const <a class="el" href="classvex_1_1vector.html">vector</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:afca1d21b77d4ea7494aa032c9bb81db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast <a class="el" href="classvex_1_1vector.html" title="Device vector. ">vex::vector</a> to a raw pointer.  <a href="#afca1d21b77d4ea7494aa032c9bb81db8">More...</a><br/></td></tr>
<tr class="separator:afca1d21b77d4ea7494aa032c9bb81db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="memTemplParams" colspan="2">template&lt;class Expr &gt; </td></tr>
<tr class="memitem:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="memTemplItemLeft" align="right" valign="top">expr_permutation&lt; Expr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">permutation</a> (const Expr &amp;expr)</td></tr>
<tr class="memdesc:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns permutation functor which is based on an integral expression.  <a href="#a1d8048e3bb5185ab018e9d0a0649ef0b">More...</a><br/></td></tr>
<tr class="separator:a1d8048e3bb5185ab018e9d0a0649ef0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fee73e544429d5e986f932a26cb4408"><td class="memTemplParams" colspan="2"><a class="anchor" id="a1fee73e544429d5e986f932a26cb4408"></a>
template&lt;class RDC , typename Expr , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:a1fee73e544429d5e986f932a26cb4408"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; Expr, <br class="typebreak"/>
NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a1fee73e544429d5e986f932a26cb4408">reduce</a> (const vector_view&lt; Expr, <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &gt; &amp;view, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:a1fee73e544429d5e986f932a26cb4408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vector_view along specified dimensions. <br/></td></tr>
<tr class="separator:a1fee73e544429d5e986f932a26cb4408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="memTemplParams" colspan="2"><a class="anchor" id="a8ed38cdf2814b4c0a339c59868a52ec4"></a>
template&lt;class RDC , typename Expr , size_t NDIM&gt; </td></tr>
<tr class="memitem:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; Expr, <br class="typebreak"/>
NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a8ed38cdf2814b4c0a339c59868a52ec4">reduce</a> (const vector_view&lt; Expr, <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &gt; &amp;view, size_t reduce_dim)</td></tr>
<tr class="memdesc:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce vector_view along specified dimension. <br/></td></tr>
<tr class="separator:a8ed38cdf2814b4c0a339c59868a52ec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14a59d7fe62f48a61cadd5098f82f80"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab14a59d7fe62f48a61cadd5098f82f80"></a>
template&lt;class RDC , typename Expr , size_t NDIM, size_t NR&gt; </td></tr>
<tr class="memitem:ab14a59d7fe62f48a61cadd5098f82f80"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename <br class="typebreak"/>
boost::proto::result_of::as_child<br class="typebreak"/>
&lt; const Expr, vector_domain &gt;<br class="typebreak"/>
::type, NDIM, NR, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ab14a59d7fe62f48a61cadd5098f82f80">reduce</a> (const <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &amp;slice, const Expr &amp;expr, const std::array&lt; size_t, NR &gt; &amp;reduce_dims)</td></tr>
<tr class="memdesc:ab14a59d7fe62f48a61cadd5098f82f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimensions. <br/></td></tr>
<tr class="separator:ab14a59d7fe62f48a61cadd5098f82f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac77b2a657d4d26f3b8348c9ac1be02f4"></a>
template&lt;class RDC , typename Expr , size_t NDIM&gt; </td></tr>
<tr class="memitem:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="memTemplItemLeft" align="right" valign="top">reduced_vector_view&lt; typename <br class="typebreak"/>
boost::proto::result_of::as_child<br class="typebreak"/>
&lt; const Expr, vector_domain &gt;<br class="typebreak"/>
::type, NDIM, 1, RDC &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac77b2a657d4d26f3b8348c9ac1be02f4">reduce</a> (const <a class="el" href="structvex_1_1gslice.html">gslice</a>&lt; NDIM &gt; &amp;slice, const Expr &amp;expr, size_t reduce_dim)</td></tr>
<tr class="memdesc:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce sliced expression along specified dimension. <br/></td></tr>
<tr class="separator:ac77b2a657d4d26f3b8348c9ac1be02f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159a23f567b28d7d284fa0cd720e900a"><td class="memTemplParams" colspan="2">template&lt;class Expr , size_t Nout, size_t Nin&gt; </td></tr>
<tr class="memitem:a159a23f567b28d7d284fa0cd720e900a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a> (const Expr &amp;expr, const std::array&lt; size_t, Nout &gt; &amp;dst_dims, const std::array&lt; size_t, Nin &gt; &amp;src_dims) -&gt; decltype(<a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(detail::reshape_helper&lt; Nout, Nin &gt;(dst_dims, src_dims)())(expr))</td></tr>
<tr class="memdesc:a159a23f567b28d7d284fa0cd720e900a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshapes given expression.  <a href="#a159a23f567b28d7d284fa0cd720e900a">More...</a><br/></td></tr>
<tr class="separator:a159a23f567b28d7d284fa0cd720e900a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac11898b99f6b77ea08316ac19f0e7e86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac11898b99f6b77ea08316ac19f0e7e86"></a>
const <a class="el" href="structvex_1_1range.html">range</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ac11898b99f6b77ea08316ac19f0e7e86">_</a></td></tr>
<tr class="memdesc:ac11898b99f6b77ea08316ac19f0e7e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for an unbounded range. <br/></td></tr>
<tr class="separator:ac11898b99f6b77ea08316ac19f0e7e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad713fa361047b676e76f2f2d3342dcdd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad713fa361047b676e76f2f2d3342dcdd"></a>
const extent_gen&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#ad713fa361047b676e76f2f2d3342dcdd">extents</a></td></tr>
<tr class="memdesc:ad713fa361047b676e76f2f2d3342dcdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object for specifying slicer dimensions. <br/></td></tr>
<tr class="separator:ad713fa361047b676e76f2f2d3342dcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c759e462ecb32cf236b5e5379da2f1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73c759e462ecb32cf236b5e5379da2f1"></a>
const index_gen&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevex.html#a73c759e462ecb32cf236b5e5379da2f1">indices</a></td></tr>
<tr class="memdesc:a73c759e462ecb32cf236b5e5379da2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper object for specifying slicer shape. <br/></td></tr>
<tr class="separator:a73c759e462ecb32cf236b5e5379da2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Vector expression template library for OpenCL. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae178cb03057d2aed93ab059c78631e8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator vex::copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy range from device vector to host vector. </p>
<p>Copy range from host vector to device vector. </p>

</div>
</div>
<a class="anchor" id="ac74a209f956b87b8dc289aad5498a25c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vex::device_spmv_perf </td>
          <td>(</td>
          <td class="paramtype">const backend::command_queue &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weights device wrt to additive_operator performance. </p>
<p>Launches the following kernel on each device: </p>
<div class="fragment"><div class="line">* y = A * x;</div>
<div class="line">* </div>
</div><!-- fragment --><p> where x and y are vectors, and A is matrix for 3D Poisson problem in square domain. Each device gets portion of the vector proportional to the performance of this operation. </p>

<p>References <a class="el" href="classvex_1_1SpMat.html#a8d3b691e6259530d43489215104d9d4a">vex::SpMat&lt; val_t, col_t, idx_t &gt;::apply()</a>, <a class="el" href="classvex_1_1profiler.html#a62711181c6649461f6df957db5f22b0a">vex::profiler&lt; Clock &gt;::tic_cl()</a>, and <a class="el" href="classvex_1_1profiler.html#a0297c22109f3ede4376b33b85a0f3a1c">vex::profiler&lt; Clock &gt;::toc()</a>.</p>

</div>
</div>
<a class="anchor" id="a3688791c9b5aa7a26c7a63d9684b481c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vex::device_vector_perf </td>
          <td>(</td>
          <td class="paramtype">const backend::command_queue &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Weights device wrt to vector performance. </p>
<p>Returns device weight after simple bandwidth test.</p>
<p>Launches the following kernel on each device: </p>
<div class="fragment"><div class="line">* a = b + c;</div>
<div class="line">* </div>
</div><!-- fragment --><p> where a, b and c are device vectors. Each device gets portion of the vector proportional to the performance of this operation. </p>

<p>References <a class="el" href="classvex_1_1profiler.html#a62711181c6649461f6df957db5f22b0a">vex::profiler&lt; Clock &gt;::tic_cl()</a>, and <a class="el" href="classvex_1_1profiler.html#a0297c22109f3ede4376b33b85a0f3a1c">vex::profiler&lt; Clock &gt;::toc()</a>.</p>

</div>
</div>
<a class="anchor" id="acf35349b5accc05f96b291457f522acb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">elem_index vex::element_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When used in vector expression, returns current element index plus offset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>Element indices will start from this value. </td></tr>
    <tr><td class="paramname">length</td><td>Specify length of vector expression. This is only relevant when parent expression does not contain any vectors. See monte_carlo_pi test in tests/random.cpp for an example. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a629ee8dc1d5241fcfbc0289fbb8e7b0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vex::equal_weights </td>
          <td>(</td>
          <td class="paramtype">const backend::command_queue &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns equal weight to each device. </p>
<p>This results in equal partitioning. </p>

</div>
</div>
<a class="anchor" id="aa04547c51b46e0005b37ad00493f7354"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename val_t , typename col_t , typename idx_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">inline_spmv&lt; <a class="el" href="classvex_1_1SpMat.html">SpMat</a>&lt;val_t, col_t, idx_t&gt;, <a class="el" href="classvex_1_1vector.html">vector</a>&lt;val_t&gt; &gt; vex::make_inline </td>
          <td>(</td>
          <td class="paramtype">const additive_operator&lt;SpMat&lt; val_t, col_t, idx_t &gt;, vector&lt; val_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inlines a sparse matrix - vector product. </p>
<p>When applied to a matrix-vector product, the product becomes inlineable. That is, it may be used in any vector expression (not just additive expression). This is only possible in single-device contexts, so user has to guarantee that.</p>
<p>Example: </p>
<div class="fragment"><div class="line">* <span class="comment">// Get maximum residual value:</span></div>
<div class="line">* eps = sum( fabs(f - <a class="code" href="namespacevex.html#aa04547c51b46e0005b37ad00493f7354">vex::make_inline</a>(A * x)) );</div>
<div class="line">* </div>
</div><!-- fragment --> 
<p>References <a class="el" href="namespacevex.html#a94c7748602834bd3b8b86762a0970a94">precondition()</a>.</p>

</div>
</div>
<a class="anchor" id="ae1e84dcac8995e5fbfb0cc2848d94297"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Tag, typename T , class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">temporary&lt;T, Tag, Expr&gt; ::type vex::make_temp </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create temporary to be reused in a vector expression. </p>
<p>The type of the temporary is explicitly specified. </p>

</div>
</div>
<a class="anchor" id="aad59a3b060765aaee879da333ac3a812"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Tag, class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">temporary&lt;typename detail::return_type&lt;Expr&gt;::type, Tag, Expr&gt; vex::make_temp </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create temporary to be reused in a vector expression. </p>
<p>The type of the temporary is automatically deduced from the supplied expression. </p>

</div>
</div>
<a class="anchor" id="a1d8048e3bb5185ab018e9d0a0649ef0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">expr_permutation&lt;Expr&gt; vex::permutation </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns permutation functor which is based on an integral expression. </p>
<p>Example: </p>
<div class="fragment"><div class="line">* <span class="keyword">auto</span> reverse = <a class="code" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(N - 1 - <a class="code" href="namespacevex.html#acf35349b5accc05f96b291457f522acb">vex::element_index</a>());</div>
<div class="line">* Y = reverse(X);</div>
<div class="line">* </div>
</div><!-- fragment --> 
<p>Referenced by <a class="el" href="classvex_1_1SpMat.html#a8d3b691e6259530d43489215104d9d4a">vex::SpMat&lt; val_t, col_t, idx_t &gt;::apply()</a>, and <a class="el" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape()</a>.</p>

</div>
</div>
<a class="anchor" id="a94c7748602834bd3b8b86762a0970a94"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Condition , class Message &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::precondition </td>
          <td>(</td>
          <td class="paramtype">const Condition &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Message &amp;&#160;</td>
          <td class="paramname"><em>fail_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check run-time condition. </p>
<p>Throws std::runtime_error if condition is false </p>

<p>Referenced by <a class="el" href="namespacevex.html#aa04547c51b46e0005b37ad00493f7354">make_inline()</a>, <a class="el" href="namespacevex.html#afca1d21b77d4ea7494aa032c9bb81db8">raw_pointer()</a>, and <a class="el" href="classvex_1_1vector.html#a9c2de310d894fca15385030ae906d545">vex::vector&lt; T &gt;::vector()</a>.</p>

</div>
</div>
<a class="anchor" id="a2f3700c5a3fd689cebd1c3301266b7ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::push_compile_options </td>
          <td>(</td>
          <td class="paramtype">const backend::command_queue &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set global compute kernel compilation options for a given device. </p>
<p>This replaces any previously set options. To roll back, call <a class="el" href="namespacevex.html#ac07c402052137a80de67e1137f258341" title="Rolls back changes to compile options. ">pop_compile_options()</a>. </p>

</div>
</div>
<a class="anchor" id="aa16dc38863b68e8c2cd28a117044a3b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::push_program_header </td>
          <td>(</td>
          <td class="paramtype">const backend::command_queue &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set global compute kernel header for a given device. </p>
<p>This replaces any previously set header. To roll back, call <a class="el" href="namespacevex.html#a1f5371f8233d7cfed97b68e3126e860e" title="Rolls back changes to compile options. ">pop_program_header()</a>. </p>

</div>
</div>
<a class="anchor" id="afca1d21b77d4ea7494aa032c9bb81db8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector_pointer&lt;T&gt; vex::raw_pointer </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cast <a class="el" href="classvex_1_1vector.html" title="Device vector. ">vex::vector</a> to a raw pointer. </p>
<p>Useful when user wants to get a pointer to a vector instead of its current element inside a vector expression. Could be combined with calls to address_of/dereference operators or with user-defined functions iterating through the vector. See examples in tests/vector_pointer.cpp. </p>

<p>References <a class="el" href="classvex_1_1vector.html#a8877ef727c9a101d5a347f41c0ed6787">vex::vector&lt; T &gt;::nparts()</a>, and <a class="el" href="namespacevex.html#a94c7748602834bd3b8b86762a0970a94">precondition()</a>.</p>

</div>
</div>
<a class="anchor" id="a159a23f567b28d7d284fa0cd720e900a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Expr , size_t Nout, size_t Nin&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vex::reshape </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; size_t, Nout &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst_dims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::array&lt; size_t, Nin &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_dims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(<a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">vex::permutation</a>(detail::reshape_helper&lt;Nout, Nin&gt;(dst_dims, src_dims)())(expr))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshapes given expression. </p>
<p>Makes a multidimensional expression of dst_dims dimensions from input expression shaped as specified by src_dim. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expr</td><td>Input expression </td></tr>
    <tr><td class="paramname">dst_dims</td><td>dimensions of the resulting expression. </td></tr>
    <tr><td class="paramname">src_dims</td><td>dimensions of the input expressions. Specified as posintions in dst_dims.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p>
<div class="fragment"><div class="line">* <span class="comment">// Matrix transposition:</span></div>
<div class="line">* <span class="keyword">auto</span> B = <a class="code" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a>(A, make_array&lt;size_t&gt;(n, m), <a class="code" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a>(1, 0));</div>
<div class="line">*</div>
<div class="line">* <span class="comment">// Expand 1D vector to a 2D matrix (by copying along redundant dimension):</span></div>
<div class="line">* <span class="keyword">auto</span> A = <a class="code" href="namespacevex.html#a159a23f567b28d7d284fa0cd720e900a">reshape</a>(x, <a class="code" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a>(n, m), <a class="code" href="namespacevex.html#acec621a57aaa5e1e17619376714b34c6">make_array</a>(0));</div>
<div class="line">* </div>
</div><!-- fragment --> 
<p>References <a class="el" href="namespacevex.html#a1d8048e3bb5185ab018e9d0a0649ef0b">permutation()</a>.</p>

</div>
</div>
<a class="anchor" id="a7740d79c763aba34de005e957fb27db5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vex::set_partitioning </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; double(const backend::command_queue &amp;) &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partitioning scheme for vectors and matrices. </p>
<p>Should be set once before any object of vector or matrix type is declared. Otherwise default parttioning function (partition_by_vector_perf) is selected. </p>

</div>
</div>
<a class="anchor" id="a0ee2afe5ab14567e3900ecea19e46c78"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vex::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvex_1_1vector.html">vex::vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort. </p>
<p>If there are more than one device in vector's queue list, then all partitions are sorted individually on GPUs and then merged on CPU. </p>

<p>References <a class="el" href="namespacevex.html#aaa68b032f0d66695e3b3b6c5375e8cf6">copy()</a>, <a class="el" href="classvex_1_1vector.html#a6084024536baf2bc26d75e3734283818">vex::vector&lt; T &gt;::part_size()</a>, <a class="el" href="classvex_1_1vector.html#a52c7bf21a4d87c503bf6debfec8e2f1a">vex::vector&lt; T &gt;::part_start()</a>, <a class="el" href="classvex_1_1vector.html#ae6b48f08d3b85d3e6334425f9fa51ffd">vex::vector&lt; T &gt;::queue_list()</a>, and <a class="el" href="classvex_1_1vector.html#acba96d67dcc97afdc6ff552d913ca7d7">vex::vector&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a31259ad9c0db468f3f73e1decf8d0c14"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Tag, class Expr &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vex::tag </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td> -&gt; const tagged_terminal&lt;
                        Tag,

                &gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tags terminal with a unique (in a single expression) tag. </p>
<p>By tagging terminals user guarantees that the terminals with same tags actually refer to the same data. VexCL is able to use this information in order to reduce number of kernel parameters and unnecessary global memory I/O operations.</p>
<p>Example: </p>
<div class="fragment"><div class="line">* s = sum(tag&lt;1&gt;(x) * tag&lt;1&gt;(x) + tag&lt;2&gt;(y) * tag&lt;2&gt;(y));</div>
<div class="line">* </div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab7ed95396644bcef1aff9a0cac89e69a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Expr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">expression_tuple&lt; std::tuple&lt;const Expr&amp;...&gt; &gt; vex::tie </td>
          <td>(</td>
          <td class="paramtype">const Expr &amp;...&#160;</td>
          <td class="paramname"><em>expr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ties several vector expressions into writeable tuple. </p>
<p>The following example results in a single kernel: </p>
<div class="fragment"><div class="line">* <a class="code" href="classvex_1_1vector.html">vex::vector&lt;double&gt;</a> x(ctx, 1024);</div>
<div class="line">* <a class="code" href="classvex_1_1vector.html">vex::vector&lt;double&gt;</a> y(ctx, 1024);</div>
<div class="line">*</div>
<div class="line">* <a class="code" href="namespacevex.html#ab7ed95396644bcef1aff9a0cac89e69a">vex::tie</a>(x,y) = <a class="code" href="namespacevex.html#ab7ed95396644bcef1aff9a0cac89e69a">std::tie</a>( x + y, y - x );</div>
<div class="line">* </div>
</div><!-- fragment --><p> This is functionally equivalent to </p>
<div class="fragment"><div class="line">* tmp_x = x + y;</div>
<div class="line">* tmp_y = y - x;</div>
<div class="line">* x = tmp_x;</div>
<div class="line">* y = tmp_y;</div>
<div class="line">* </div>
</div><!-- fragment --><p> but does not use temporaries and is more efficient. </p>

<p>Referenced by <a class="el" href="namespacevex_1_1generator.html#a4c60e9f68a2e74de54a073730704532e">vex::generator::build_kernel()</a>, <a class="el" href="namespacevex_1_1generator.html#af0263b233e113206855f28eb745b7ec8">vex::generator::make_function()</a>, <a class="el" href="classvex_1_1mba.html#a5660107fe6178eec3173b39288583494">vex::mba&lt; NDIM, real &gt;::operator()()</a>, and <a class="el" href="classvex_1_1generator_1_1Kernel.html#aff818a250c0ad905cc9cd9c98cfa427e">vex::generator::Kernel&lt; NP &gt;::operator()()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
